#!/usr/sbin/nft -f
# File: passing-syntaxes.nft
# Description: A test NFT file to exercise all Vim syntax highlightings.
#
# base_cmd *
# nft_line/*
#
################################################################################
# true positive test: properly hightlighted correctly; has good content; perfect
################################################################################

table_id chain_id 
ip6 table_id chain_id 

reset map
# <common_block>
# INCLUDE done in a separate include-syntaxes.nft test file

# interfaces
define empty = { }
define empty = -1
define nic_inet = bond0
define nic2_inet = bond0 # comment
 define nic_dmz = bond1
   define    nic_lan    =    bond2   
   define    nicr3_lan    =    bond2   # comment
# network ranks
define net_ipv4_dmz = 10.0.1.0/24
define net_ipv6_dmz = fe00:1::/64
define net_ipv4_lan = 10.0.2.0/24
define net_ipv6_lan = fe00:2::/64
# some machines
define server1_ipv4 = 10.0.1.2
define server1_ipv6 = fe00:1::2
define workstation1_ipv4 = 10.0.2.2
define workstation1_ipv6 = fe00:2::2

define my_public_wan = eth2
define int_if1 = eth0
define int_if2 = $my_public_wan
define int_ifs = { "virbr0", $int_if2, "virbr1" }
redefine my_public_wan = eth2
redefine int_if1 = eth0
redefine int_if2 = $my_public_wan
redefine int_ifs = { virbr0, $int_if2, virbr1 }
undefine int_ifs 

# Implicit 'add' (add_cmd) (no 'add' keyword)
##########################################################
# 4-way pit-stop for adding a singular rule @ command line
#   (reminder: pair of curly braces provides a group of rules)
#
#    add rule
#    add
#    rule
#    <just start typing in <table_id> <chain_id> <rule>
#
# Full Syntax:
#    add rule <rule_position> <rule>
#    add <rule_position> <rule>
#    rule <rule_position> <rule>
#    <rule_position> <rule>
#
# (base_cmd->ADD->add_cmd->RULE-><rule_position>+<rule>) 
# (base_cmd->ADD->add_cmd->/*empty*/-><rule_position>+<rule>) 
# (base_cmd->/*empty*/->add_cmd->RULE-><rule_position>+<rule>) 
# (base_cmd->/*empty*/->add_cmd->/*empty*/-><rule_position>+<rule>) 
#
# Full-blown rule expansion (stopping short of expanding <rule>)
#    add rule <table_id> <chain_id> ...
#    add rule <table_id> <chain_id> position 7 ...
#    add rule <table_id> <chain_id> handle 42 ...
#    add rule <table_id> <chain_id> index 123 ...
#    add rule <family> <table_id> <chain_id> ...
#    add rule <family> <table_id> <chain_id> position <num> ...
#    add rule <family> <table_id> <chain_id> handle <num> ...
#    add rule <family> <table_id> <chain_id> index <num> ...
#    add <table_id> <chain_id> ...
#    add <table_id> <chain_id> position 7 ...
#    add <table_id> <chain_id> handle 42 ...
#    add <table_id> <chain_id> index 123 ...
#    add <family> <table_id> <chain_id> ...
#    add <family> <table_id> <chain_id> position <num> ...
#    add <family> <table_id> <chain_id> handle <num> ...
#    add <family> <table_id> <chain_id> index <num> ...
#    rule <table_id> <chain_id> ...
#    rule <table_id> <chain_id> position 7 ...
#    rule <table_id> <chain_id> handle 42 ...
#    rule <table_id> <chain_id> index 123 ...
#    rule <family> <table_id> <chain_id> ...
#    rule <family> <table_id> <chain_id> position <num> ...
#    rule <family> <table_id> <chain_id> handle <num> ...
#    rule <family> <table_id> <chain_id> index <num> ...
#    <table_id> <chain_id> <rule>  # somehow, this didn't work for me
#    <table_id> <chain_id> position 7 ...
#    <table_id> <chain_id> handle 42 ...
#    <table_id> <chain_id> index 123 ...
#    <family> <table_id> <chain_id> ...
#    <family> <table_id> <chain_id> position <num> ...
#    <family> <table_id> <chain_id> handle <num> ...
#    <family> <table_id> <chain_id> index <num> ...
#
# Template and organize it under:
#
# /* empty */ table <table_spec>  # base_cmd; (without the 'add' keyword)
# Bison: TABLE table_spec 
table myIpTable 
table my.IpTable
table my/IpTable
table my_IpTable
table my./_IpTable
table netdev myNetdev 
table bridge myBridge 
table arp myArpTable 
table ip myIpTable 
table ip6 myIp6Table 
table inet myInetTable 
# Bison: TABLE table_spec table_block_alloc { table_block } 
table myIpTable { flags dormant; }
table netdev myNetdev { flags dormant; }
table bridge myBridge { flags dormant; }
table arp myArpTable { flags dormant; }
table ip myIpTable { flags dormant; }
table ip6 myIp6Table { flags dormant; }
table inet myInetTable { flags dormant; }
 table inet myInetTable { flags dormant; }

add chain inet T C { policy type filter hook input priority 0 }
 add chain inet T C { type filter hook input priority 0 }

table inet base_table {
  chain input_filter {
    type filter hook input priority 0;
    policy drop
    flags offload;
    devices = $MYVARIABLE;
    devices = $MYVARIABLE;   
    comment "A nice long comment line"
    iifname "lo" accept  # handle 3
    ct state established,related accept  # handle 2
    ip protocol icmp accept  # handle 4
    drop  # handle 5
    devices = { "quoted_string", $MYVAR, string }  ;
    devices = { $MYVARIABLE } ;;;;;    ;
    devices = { MYVARIABLE } ;;;;;    ;
    devices = { br0 };
    devices = { "wlan1" };
    devices = { "br0", $MYVARIABLE, eth0 };
    devices = { br0,eth0 };
  }
}

table inet base_filter {
	chain input_filter {
	        type filter hook input priority 0;
        }
}
table inet base_table {
        chain input_filter { # handle 1
                 type filter hook input priority 0; # handle 2
                 tcp dport http drop # handle 3
        }
        chain output_filter { # handle 4
                 type filter hook input priority 0; # handle 5
                 tcp sport http drop # handle 6
        }
}
flush ruleset

table netdev filter {
  # Basic filter chain, devices can be configued to jump here
  chain ingress_filter {
    # Drop all fragments.
    ip frag-off & 0x1fff != 0 counter drop

    # Drop XMAS packets.
    tcp flags & (fin|syn|rst|psh|ack|urg) == fin|syn|rst|psh|ack|urg counter drop
    tcp option at echo,1,2 counter drop
    tcp option at eol,1,2 counter drop
    tcp option at fastopen,1,2 counter drop
    tcp option at md5sig,1,2 counter drop
    tcp option at mptcp,1,2 counter drop
    tcp option at mss,1,2 counter drop
    tcp option at nop,1,2 counter drop
    tcp option at timestamp,1,2 counter drop
    tcp option at window,1,2 counter drop
    tcp option at num,1,2 counter drop
    tcp option at echo,123,123 counter drop
    tcp option echo counter drop
    tcp option echo 1 counter drop
    tcp option eol counter drop
    tcp option eol 1 counter drop
    tcp option fastopen counter drop
    tcp option fastopen 1 counter drop
    tcp option md5sig counter drop
    tcp option md5sig 1 counter drop
    tcp option mptcp & (fin|syn|rst|psh|ack|urg) == fin|syn|rst|psh|ack|urg counter drop
    tcp option mptcp subtype ,1,2 & (fin|syn|rst|psh|ack|urg) == fin|syn|rst|psh|ack|urg counter drop
    tcp option mss counter drop
    tcp option mss 1 counter drop
    tcp option num counter drop
    tcp option num 1 counter drop
    tcp option nop counter drop
    tcp option nop 1 counter drop
    tcp option sack counter drop
    tcp option sack 1 counter drop
    tcp option sack0  counter drop
    tcp option sack0 1 counter drop
    tcp option sack1 counter drop
    tcp option sack1 1 counter drop
    tcp option sack2 counter drop
    tcp option sack2 1 counter drop
    tcp option sack3 counter drop
    tcp option sack3 1 counter drop
    tcp option sack-permitted counter drop
    tcp option sack-permitted 1 counter drop
    tcp option timestamp counter drop
    tcp option timestamp tsecr 123123 counter drop
    tcp option timestamp tsval 123123 counter drop
    tcp option window counter drop
    tcp option window 1 counter drop
    tcp sport
    tcp dport
    tcp sequence 
    tcp ackseq 
    tcp doff 
    tcp reserved 
    tcp flags 
    tcp windows 
    tcp checksum 
    tcp urgptr 

    # Drop NULL packets.
    tcp flags & (fin|syn|rst|psh|ack|urg) == 0x0 counter drop

    # Drop uncommon MSS values.
    tcp flags syn tcp option maxseg size 1-535 counter drop

  }
}

table inet filter {
  chain input {
    type filter hook input priority 200; 
    policy drop;
    counter jump input_hook
    counter jump base_filter
    log prefix Dropped counter drop
    log prefix "Dropped input traffic: " counter drop
    log prefix 'Dropped input traffic: ' counter drop
  }
  chain input_hook {
  }

  chain base_filter {
    type filter hook input priority 200; 
    counter jump drop_filter
    ct state vmap {
      established: accept,
      related: accept,
      new: continue,
      invalid: drop
    }
    # Allow loopback traffic
    iifname lo counter accept
    oifname lo counter accept
  }

  chain drop_filter {
  }

  chain forward {
    type filter hook forward priority 200; policy drop;
    counter jump forward_hook
    counter jump base_filter
    log prefix "Dropped forwarded traffic: " counter drop
  }

  chain forward_hook {
  }

  chain output {
    type filter hook output priority 200; policy drop;
    counter jump output_hook
    counter jump base_filter
    log prefix "Dropped output traffic: " counter drop
  }
  chain output_hook {
  }
}

table inet nat {
  chain prerouting {
    type nat hook prerouting priority 0;
    policy $chain_drop_type
  }
  chain postrouting {
    type nat hook postrouting priority 500;
  }
}
include "/etc/nftables.rules.d/*.rules"

define lan_interface = fib.lan
define wifi_interface = ax1800
define management_interface = fib.management
define dmz_interface = ethernet2

define wan_interface = fib.wan

define wifi_network = 192.168.1.0/24
define lan_network = 192.168.10.0/24
define management_network = 192.168.255.0/24
define dmz_network = 192.168.2.0/24

table inet filter {
  set trusted_nets {
    type ipv4_addr
    flags interval
    elements = { $lan_network, $wifi_network }
  }
  set dmz_nets {
    type ipv4_addr
    flags interval
    elements = { $dmz_network }
  }
  set untrusted_nets {
    type ipv4_addr
    flags interval
    elements = { $dmz_network }
  }
}
table netdev filter {
  chain ingress {
    type filter hook ingress device fib1 priority -500;
    jump ingress_filter
  }
  chain ingress {
    type filter hook ingress device fib2 priority -500;
    jump ingress_filter
  }
}

define dmz_spam_udp = { 1234 }
define dmz_spam_tcp = { 2350 }

table inet filter {
  set spam_udp {
    type inet_service
    elements = { $dmz_spam_udp }
  }
  set spam_tcp {
    type inet_service
    elements = { $dmz_spam_tcp }
  }

  chain drop_filter {
    tcp dport @spam_tcp counter drop
    udp dport @spam_udp counter drop
  }
}
define allowed_icmp_types = { echo-reply, echo-request }
define trusted_icmp_types = { destination-unreachable, time-exceeded }
define allowed_icmpv6_types = { nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, echo-request, echo-reply }

table inet filter {
  chain base_filter {
    ip protocol icmp jump icmp_filter
    ip6 nexthdr icmpv6 jump icmpv6_filter
  }
  chain icmp_filter {
    icmp type $allowed_icmp_types counter accept
    ip saddr @trusted_nets icmp type $trusted_icmp_types counter accept
    ip daddr @trusted_nets icmp type $trusted_icmp_types counter accept
  }
  chain icmpv6_filter {
    icmpv6 type $allowed_icmpv6_types counter accept
  }
}

define dhcp_server_interfaces = { $lan_interface, $wifi_interface, $dmz_interface }
define dhcp_client_interfaces = { $management_interface, $wan_interface }

table inet filter {
  set dhcp_server {
   type inet_service;
   elements = { 67 }
  }
  set dhcp_client {
   type inet_service;
   elements = { 68 }
  }
  set dhcp6_server {
   type inet_service;
   elements = { 547 }
  }
  set dhcp6_client {
   type inet_service;
   elements = { 546 }
  }
  chain input_hook {
    iifname $dhcp_client_interfaces udp sport @dhcp_server udp dport @dhcp_client counter accept comment "Allow DHCP client input traffic"
    iifname $dhcp_client_interfaces udp sport @dhcp6_server udp dport @dhcp6_client counter accept comment "Allow DHCPv6 client input traffic"
    iifname $dhcp_server_interfaces udp dport @dhcp_server udp sport @dhcp_client counter accept comment "Allow DHCP server input traffic"
    iifname $dhcp_server_interfaces udp dport @dhcp6_server udp sport @dhcp6_client counter accept comment "Allow DHCPv6 server input traffic"
  }
  chain output_hook {
    oifname $dhcp_client_interfaces udp dport @dhcp_server udp sport @dhcp_client counter accept comment "Allow DHCP client output traffic"
    oifname $dhcp_client_interfaces udp dport @dhcp6_server udp sport @dhcp6_client counter accept comment "Allow DHCPv6 client output traffic"
    oifname $dhcp_server_interfaces udp sport @dhcp_server udp dport @dhcp_client counter accept comment "Allow DHCP server output traffic"
    oifname $dhcp_server_interfaces udp sport @dhcp6_server udp dport @dhcp6_client counter accept comment "Allow DHCPv6 server output traffic"
  }
}

define github_ssh_servers = { 140.82.112.3, 140.82.112.4, 140.82.114.3, 140.82.113.4, 140.82.114.4, 140.82.113.3 }

table inet filter {
  set external_ssh_servers {
    type ipv4_addr
    elements = { $github_ssh_servers }
  }
  set external_ssh_clients {
    type ipv4_addr
    flags interval
    elements = { $lan_network }
  }
  set ssh_clients {
    type ipv4_addr
    flags interval
    elements = { $management_network }
  }
  set ssh_ports {
    type inet_service;
    elements = { 22 }
  }
  chain ssh_filter {
    ip saddr @external_ssh_clients ip daddr @external_ssh_servers counter accept comment "Allow these users to SSH to specified external servers"
    ip saddr @ssh_clients counter accept comment "Allow this set to SSH anywhere, including the router itself"
    skuid 1000 ip daddr @external_ssh_servers counter accept comment "Allow SSH traffic from UID 1000 to allowed external servers"
  }
}

table inet filter {
  set ntp_ports {
    type inet_service
    elements = { 123 }
  }
  set ntp4_ports {
    type inet_service
    elements = { 4460 }
  }
  chain base_filter {
    tcp dport @ntp4_ports counter jump ntp_filter
    udp dport @ntp_ports counter jump ntp_filter
  }
  chain ntp_filter {
    ip saddr @trusted_nets counter accept
    skuid 123 counter accept
  }
}

table inet nat {
  set nat_nets {
    type ipv4_addr
    flags interval
    elements = { $lan_network, $wifi_network, $dmz_network }
  }
  chain	postrouting {
    oifname $wan_interface ip saddr @nat_nets counter masquerade
  }
}

define docker_default_net = 172.17.0.0/16
define docker_server_net = 10.100.100.0/24
define docker_nets = { $docker_default_net, $docker_server_net }

table inet filter {
  set docker_nets {
    type ipv4_addr
    flags interval
    elements = { $docker_nets }
  }
  set dns_ports {
    type inet_service
    elements = { 53 }
  }
  set web_ports {
    type inet_service
    elements = { 443 }
  }

  chain docker_filter {
    udp dport @dns_ports counter accept
    oifname $wan_interface tcp dport @web_ports counter accept
  }
  chain forward_hook {
    ip saddr @docker_nets counter jump docker_filter
  }
}

table inet nat {
  set nat_nets {
    type ipv4_addr
    flags interval
    elements = { $docker_nets }
  }
}

table netdev filter {
  set blocked_ipv4 {
    auto-merge
    169.254.0.0/16,
    224.0.0.0/3,
    240.0.0.0/5
  }
  # fix the last two IPs overlapping
}

table netdev filter {
  chain ingress {
    type filter hook ingress device enp4s0 priority -500;

    # Drop all fragments.
    ip frag-off & 0x1fff != 0 counter drop

    # Drop XMAS packets.
    tcp flags & (fin|syn|rst|psh|ack|urg) == fin|syn|rst|psh|ack|urg counter drop

    # Drop NULL packets.
    tcp flags & (fin|syn|rst|psh|ack|urg) == 0x0 counter drop

    # Drop uncommon MSS values.
    tcp flags syn tcp option maxseg size 1-535 counter drop

  }
}


# /* empty */ chain <chain_spec>  (without the 'add' keyword)
# Bison: CHAIN chain_spec 
chain myTable myChain
chain my_._ArpTable my._ArpChain 
# Bison: CHAIN chain_spec chain_block_alloc { chain_block } 
chain MyTable ARP_INPUT_FILTER {
    type filter hook input priority 0;
    policy drop;
    counter log drop
}

# /* empty */ rule <rule_position> rule  # base_cmd; (without the 'add' keyword)
# Bison: RULE rule_position rule 
# Bison: RULE chain_spec rule
# Bison: RULE chain_spec rule_alloc
# Bison: RULE chain_spec rule_alloc # comment
# Bison: RULE <chain_spec> <stmt_alloc> [ [*]+ <stmt_alloc> ]* [;]* # comment
rule ip myIpTable myIpChain accept
rule ip myIpTable myIpChain tcp dport 23 accept
rule ip6 myIpTable myIpChain accept
rule inet mytable myin jump nuts
rule inet mytable myin counter jump nuts;
rule inet mytable myin jump toMe accept;
rule inet mytable myin counter accept
rule inet mytable myin counter accept comment "foo bar"
rule arp myArpTable myArpChain jump ArpProxy
rule bridge myBridgeTable myBridgeChain jump BridgeSpan
rule netdev myNetdevTable myNetdevChain fwd to eth1
# Bison: RULE chain_spec position_spec rule
rule ip myIpTable myIpChain position 14 accept
# Bison: RULE chain_spec handle_spec rule
rule ip myIpTable myIpChain handle 14 accept
# Bison: RULE chain_spec index_spec rule
rule ip myIpTable myIpChain index 14 accept
#rule ip myIpTable myIpChain { tcp ; }
rule ip myIpTable myIpChain tcp dport { 22, 80, 443 } accept

# /* empty */ set <set_spec> set_block_alloc { set_block }  (without the 'add' keyword)
# Bison: SET set_spec set_block_alloc { set_block } 

set myTable mySetName { type inet_proto; }
set myIpTable mySet { type mark; flags interval; timeout 15m; gc-interval 2d; size 1200; policy memory; auto-merge; }
set filter blackhole { type ipv4_addr ; }
set filter set1 { type ipv4_addr ; policy memory ; }
set filter set1 { type ipv4_addr ; policy performance ; }
set ip myIpTable mySet {   # comment
    type inet.proto;   # comment
    typeof inet.proto;   # comment
    flags constant,dynamic,timeout,interval;   # comment
    timeout 30s;   # comment
    gc-interval 2h;   # comment
    elements = {ip};   # comment
    auto-merge;   # comment
    size 1200   # comment
    size 1200;   # comment
    policy memory;   # comment
    policy performance;   # comment
    };  # comment
}
set netdev myNetdevTable myNetdevSet { type ether_addr; flags interval; timeout 15m; gc-interval
    2d; elements = {mark, ipv4_addr; ipv6_addr; }; size 1200; policy performance; auto-merge; }
set netdev myNetdevTable myNetdevSet { type ether_addr; flags interval; timeout 15m; gc-interval 2d; size 1200; policy performance; auto-merge; }
set bridge myBridgeTable myBridgeSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements =         {ether_addr}; size 1200; policy memory; auto-merge; }
set arp myArpTable myArpSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ipv4_addr}; size 1200; policy performance; auto-merge; }
set ip myIpTable myIpSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ipv4_addr}; size 1200; policy memory; auto-merge; }
set ip6 myIp6Table myIp6Set { type inet_service; flags interval; timeout 15m; gc-interval 2d; elements = {ipv6_addr}; size 1200; policy memory; auto-merge; }
set inet myInetTable myInetSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ipv4_addr,ipv6_addr}; size 1200; policy performance; auto-merge; }
set ip filter blackhole { type ipv4_addr; flags timeout; size 65536; }
# set <set_spec> { <set_block> }
set my_filter_table my_ssh_meter { type ipv4_addr . inet_proto; flags dynamic ;}
###set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags timeout . dynamic ;}
set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags timeout;}
set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags dynamic;}

# /* empty */ map <set_spec> map_block_alloc { map_block }  (without the 'add' keyword)
# Bison: MAP set_spec map_block_alloc { map_block } 
####map myIpTable myIpMap { type mark . mark; flags interval;}
####map myIpTable myIpMap { type mark : 5; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
###map netdev myNetdevTable myNetdevMap { type mark; flags interval; elements = { ether_addr }; size 1200; policy performance; }
###map bridge myBridgeTable myBridgeMap { type mark; flags interval; elements = { ether_addr }; size 1200; policy performance; }
###map arp myArpTable myArpMap { type mark; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
map ip myIpTable myIpMap { type inet_service: ipv4_addr; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
###map ip6 myIp6Table myIp6Map { type mark; flags interval; elements = { ipv6_addr }; size 1200; policy performance; }
###map inet myInetTable myInetMap { type mark; flags interval; elements = { inet_proto }; size 1200; policy performance; }
map filter whitelist { type ipv4_addr . inet_service : ipv6_addr; }
map filter ports { type inet_service : ipv4_addr ; }

# /* empty */ element <set_spec> set_block_expr  # without the 'add' keyword
# Bison: ELEMENT set_spec set_block_expr 
define MEAT = "drop"
element filter blackhole $MEAT 


# Bison: ELEMENT set_spec set_block_expr set_block_alloc { set_block } 
element filter blackhole { 192.168.0.1, 192.168.0.10 }
###element myIpTable myIpMap { elements = { ipv4_addr }; }
###element netdev myNetdevTable myNetdevMap { elements = { ether_addr } ; }
###element bridge myBridgeTable myBridgeMap { elements = { ether_addr } ; }
###element arp myArpTable myArpMap { elements = { ipv4_addr } ; }
###element ip myIpTable myIpMap { elements = { ipv4_addr } ; }
###element ip6 myIp6Table myIp6Map { elements = { ipv6_addr } ; }
###element inet myInetTable myInetMap { elements = { ipv4_addr } ; }
element filter ports { 80 : "http-quota" }
element filter ports { 22 : "ssh-quota" }
element ip myIpTable myTestMap { 10.11.1.15 : jump test_1_15 }
element filter blackhole { 10.2.3.4, 10.23.1.42 }

# flowtable <flowtable_spec> { <flowtable_block> }  # without the 'add' keyword
# Bison: FLOWTABLE flowtable_spec flowtable_block_alloc { flowtable_block } 
flowtable myIpTable chain_id { devices = $MYDEVICE ; }
flowtable myIpTable chain_id { devices = { eth0, eth1 } ; }
flowtable myIpTable myIpFT { devices = { eth0, eth1 } ; }
# Bison: FLOWTABLE flowtable_spec flowtable_block_alloc { HOOK type PRIORITY NUM; flowtable_block } 
flowtable myIpTable myIpFT { hook input priority 0; devices = { eth0, eth1 } ; }
flowtable ip myIpTable myIpFT { hook input priority 0; devices = { eth0, eth1 } ; }
flowtable ip6 myIp6Table myIp6FT { hook input priority 0; devices = { eth0, eth1 } ; }
flowtable inet myInetTable myInetFT { hook input priority 0; devices = { eth0, eth1 } ; }
define DEV_PRIVATE = eth0
define DEV_INTERNET = eth1
flowtable myTable f {
    hook ingress priority 0;
    devices = { $DEV_PRIVATE, $DEV_INTERNET };
};

# counter <obj_spec>  # without the 'add' keyword
# Bison: COUNTER obj_spec close_scope_counter 
counter myIpTable https-filter
counter netdev myNetdevTable https-filter  
counter bridge myBridgeTable https-filter  
counter arp myArpTable https-filter  
counter ip myIpTable https-filter  
counter ip6 myIp6Table https-filter  
counter inet myInetTable https-filter  
# counter <obj_spec> <counter_obj>  # TBD
# counter obj_spec counter_obj counter_config close_scope_counter  # TBD
# counter obj_spec counter_obj counter_config { counter_block } close_scope_counter  # TBD

# quota <obj_spec> <quota_odj>  # without the 'add' keyword
# Bison: COUNTER obj_spec quota_obj quota_config close_scope_quota 
quota filter http-quota over 25 mbytes
quota netdev myIpfilter http-quota over 25 mbytes;
quota bridge myIpfilter http-quota over 25 mbytes
quota arp myIpfilter http-quota over 25 mbytes
quota ip myIpfilter http-quota over 25 mbytes
quota ip6 myIpfilter http-quota until 525 kbytes
quota inet myIpfilter http-quota over 25 mbytes
# Bison: COUNTER obj_spec quota_obj quota_config { quota_block } close_scope_quota 
quota filter http-quota { over 25 mbytes };
quota filter ssh-quota { 10 kbytes }

# Bison: CT HELPER obj_spec ct_obj ct_config { ct_block } close_scope_ct 
# ct helper <obj_spec> { <ct_helper_block> }
# ct helper <table_spec> <chain_id> { <ct_helper_block> }
# ct helper <family_spec> <table_id> <chain_id> { <ct_helper_block> }
# ct helper <obj_spec> { }
add rule ip6 myTable myChain position 1 ct l3proto zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct proto zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct mark zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct state zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct direction zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct status zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct expiration zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct helper zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct saddr zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct daddr zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct proto-src zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct proto-dst zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct label zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct event zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct secmark zone set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct id zone set ip6 myIpTable myCTHchain { };

add rule ip6 myTable myChain position 1 ct bytes set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct packets set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct avgpkt set ip6 myIpTable myCTHchain { };
add rule ip6 myTable myChain position 1 ct zone set ip6 myIpTable myCTHchain { };

rule ip6 myTable myChain position 1 ct helper set ip6 myIpTable myCTHchain { };
rule ip6 myTable myChain position 1 ct original set ip myIpTable myCTHchain { };
rule ip6 myTable myChain position 1 ct reply set inet myIpTable myCTHchain { };
# ct helper <obj_spec> { <stmt_separator> }
ct helper myIpTable myCTHchain { ; }
ct helper myIpTable myCTHchain { ; };
# ct helper <obj_spec> { <common_block> }
# ct helper <obj_spec> { <include> }
# ct helper <obj_spec> { <define> }
# ct helper <obj_spec> { <redefine> }
# ct helper <obj_spec> { <undefine> }
# ct helper <obj_spec> { <ct_helper_config> }
# ct helper <obj_spec> { type <quoted_str> protocol <ct_l4protoname> }
ct helper myIpTable myCTHchain { type "sip" protocol tcp; l3proto ip; }
ct helper ip myIpTable cth { type "sip" protocol tcp; l3proto ip; }
ct helper ip6 myIpTable cth { type "sip" protocol tcp; l3proto ip; }
ct helper inet myIpTable cth { type "sip" protocol tcp; l3proto ip; }
ct helper arp myIpTable cth { type "sip" protocol tcp; l3proto ip; }
ct helper bridge myIpTable cth { type "sip" protocol tcp; l3proto ip; }
ct helper netdev myIpTable cth { type "sip" protocol tcp; l3proto ip; }

# ct timeout obj_spec ct_obj_alloc { ct_timeout_block } close_scope_ct
ct timeout myIpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout netdev myNetdevTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout bridge myBridgeTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout arp myArpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout ip myIpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout ip6 myIp6Table ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout inet myInetTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
ct timeout myTable agressive-tcp {
        l3proto ip;
        protocol tcp;
        policy = {established: 100, close_wait: 4, close: 4}
    }

ct expectation myTable myExpectation { ; }
ct expectation myTable myExpectation { ; } 
ct expectation myTable e_pgsql {
        protocol tcp
        dport 5432
        timeout 1h
        size 12
        l3proto ip
    }


# limit <obj_spec> <limit_obj> (without the 'add' keyword)
# Bison: LIMIT obj_spec limit_obj limit_config close_scope_limit 
limit myIpTable myIpLimit rate 1/second 
limit netdev myNetdevTable myNetdevLimit rate 1/minute 
limit bridge myBridgeTable myBridgeLimit rate 1 /hour 
limit ip myIpTable myIpLimit rate 1/ day
limit ip6 myIp6Table myIp6Limit rate 1 / week
limit inet myInetTable myInetLimit rate 1/second
# Bison: limit_packets, limit_burst_packets
limit myIpTable myIpLimit rate 1/second burst 15 packets
# Bison: limit_bytes, limit_burst_bytes
###limit myIpTable myIpLimit rate 1/second burst 1514 bytes  # new
# Bison: LIMIT obj_spec limit_obj limit_config { limit_block } close_scope_limit 
limit myTable lim_400ppm { rate 400/minute ; comment "use to limit incoming icmp" ; }
limit myTable lim_1kbps  { rate over 1024 bytes/second burst 512 bytes ; comment "use to limit incoming smtp" ; }

# secmark obj_spec secmark_obj secmark_config close_scope_secmark (without 'add' keyword)
# Bison: SECMARK obj_spec secmark_obj secmark_config { secmark_block } close_scope_secmark 
secmark myTable myTable mySecMark 
# Bison: SECMARK obj_spec secmark_obj secmark_config { common_block } close_scope_secmark 
secmark myTable sshtag { "system_u:object_r:ssh_server_packet_t:s0" }
# Bison: SECMARK obj_spec secmark_obj secmark_config { common_block; common_block } close_scope_secmark (w/o 'add')

# Named synproxy
#   synproxy obj_spec synproxy_obj synproxy_config close_scope_synproxy (without the 'add' keyword)
#   Bison: SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy 
synproxy myTable synproxy_obj mss 1500 wscale 7;
synproxy ip myTable synproxy_obj mss 1492 wscale 5;
synproxy ip6 myTable synproxy_obj mss 1498 wscale 6;
synproxy inet myTable synproxy_obj mss 1496 wscale 4;
synproxy arp myTable synproxy_obj mss 1512  wscale 2;
synproxy bridge myTable synproxy_obj mss 1518 wscale 3;
synproxy netdev myTable synproxy_obj mss 1593 wscale 1
#   Bison: SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy (w/o 'add')
synproxy myTable https-synproxy {
    mss 1460
    wscale 7
    timestamp sack-perm
}
synproxy myTable other-synproxy {
    mss 1460
    wscale 5
}


# Explicit 'add_cmd' (uses keyword 'add')
# add table <table_spec>
add table myIpTable 
add table my.IpTable
add table my/IpTable
add table my_IpTable
add table my./_IpTable
add table netdev myNetdev 
add table bridge myBridge 
add table arp myArpTable 
add table ip myIpTable 
add table ip6 myIp6Table 
add table inet myInetTable 
add table myIpTable    # defaults to 'ip' family
add table my_.IpTable    # defaults to 'ip' family

# add table <table_spec> { <table_block> }
add table myIpTable { flags dormant } ;
add table myIpTable { flags dormant; } ;
add table myIpTable { flags dormant ; } ;
add table myIpTable { flags dormant ;};
add table myIpTable { flags dormant,idle } ; 
add table myIpTable { flags dormant,idle; } ;
add table netdev myNetdev { flags dormant ; }
add table myIpTable { flags dormant,idle;} 
add table bridge myBridge { flags dormant; }
add table arp myArpTable { flags dormant; }
add table ip myIpTable { flags dormant; }
add table ip6 myIp6Table { flags dormant; }
add table inet myInetTable { flags dormant; }

add chain myIpTable myIpChain 
add chain netdev myNetdevTable myNetdevTable 
add chain bridge myBridgeTable myBridgeChain 
add chain arp myArpTable myArpChain 
add chain ip myIpTable myIpChain 
add chain ip6 myIp6Table myIp6Chain 
add chain inet myInetTable myInetChain 

# add chain <chain_spec> { <chain_block> }  # group of rules
add chain myIpTable myIpChain { type filter hook input priority 0; policy drop;}
add chain myIpTable myIpChain { type filter hook input device eth0 priority 0; policy drop;}
add chain netdev myNetdevTable myNetdevChain { type filter hook ingress device eth1 priority 0; policy drop;}
add chain arp myArpTable myArpChain { type filter hook input device eth1 priority 0; policy drop;}
add chain arp myArpTable myArpChain { type filter hook output priority 0; policy drop;}
add chain arp myArpTable myArpChain { type filter hook input device eth0 priority 0; policy accept;}
add chain arp myArpTable myArpChain { type filter hook output device eth0 priority 0; policy accept;}
add chain arp myArpTable myArpChain { type filter hook output devices = { eth0, eth1 }    priority 0; policy accept;}
add chain bridge myBridgeTable myBridgeChain { type filter hook input priority 0; policy drop;}
add chain bridge myBridgeTable myBridgeChain { type filter hook output priority 0; policy drop;}
add chain bridge myBridgeTable myBridgeChain { type filter hook prerouting priority 0; policy drop;}
add chain bridge myBridgeTable myBridgeChain { type filter hook postrouting priority 0; policy drop;}
add chain bridge myBridgeTable myBridgeChain { type filter hook input device eth0 priority 0; policy drop;}
add chain netdev myNetdevTable myNetdevChain { type filter hook ingress device eth0 priority 0; policy drop;}
add chain ip myIpTable myIpChain { type filter hook input priority 0; policy accept; }
add chain ip myIpTable myIpChain { type filter hook input device eth0 priority 0; policy drop;}
add chain ip6 myIp6Table myIp6Chain { type filter hook input priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type filter hook prerouting priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type filter hook forward priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type filter hook output priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type filter hook postrouting priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type nat hook prerouting priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type nat hook input priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type nat hook output priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type nat hook postrouting priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type route hook output priority 0; policy accept; }
add chain ip6 myIp6Table myIp6Chain { type filter hook input device eth0 priority 0; policy drop;}
add chain inet myInetTable myInetChain { type filter hook prerouting priority 0; policy accept; }
add chain inet myInetTable myInetChain { type filter hook input priority 0; policy accept; }
add chain inet myInetTable myInetChain { type filter hook forward priority 0; policy accept; }
add chain inet myInetTable myInetChain { type filter hook output priority 0; policy accept; }
add chain inet myInetTable myInetChain { type filter hook postrouting priority 0; policy accept; }
add chain inet myInetTable myInetChain { type filter hook prerouting priority 0; policy accept; }
add chain inet myInetTable myInetChain { type nat hook input priority 0; policy accept; }
add chain inet myInetTable myInetChain { type nat hook output priority 0; policy accept; }
add chain inet myInetTable myInetChain { type nat hook postrouting priority 0; policy accept; }
add chain inet myInetTable myInetChain { type route hook output priority 0; policy accept; }
add chain inet myInetTable myInetChain { type filter hook input device eth0 priority 0; policy drop;}

#    add rule <table_id> <chain_id> ...
add rule filter output ip daddr 192.168.0.0/24 accept # 'ip filter' is assumed
add rule myIpTable myIpChain accept
add rule filter output quota name tcp dport map @ports
add rule nat prerouting dnat tcp dport map { 1000 : 1.1.1.1, 2000 : 2.2.2.2, 3000 : 3.3.3.3} \
      : tcp dport map { 1000 : 1234, 2000 : 2345, 3000 : 3456 }
add rule nat postrouting snat \
      ip saddr map { 192.168.1.1 : 1.1.1.1, 192.168.2.2 : 2.2.2.2, 192.168.3.3 : 3.3.3.3 }
add rule filter input snat ip saddr map { 1.1.1.0/24 : 192.168.3.11, 2.2.2.0/24 : 192.168.3.12}

#    add rule <table_id> <chain_id> position 7 ...
add rule myIpTable myIpChain position 5 accept

#    add rule <table_id> <chain_id> handle 42 ...
add rule myIpTable myIpChain handle 51 accept

#    add rule <table_id> <chain_id> index 123 ...

#    add rule <family> <table_id> <chain_id> ...
add rule myIpTable myIpChain log ip dscp cs1
add rule myIpTable myIpChain ip dscp cs1 ip dscp cs2
add rule myIpTable myIpChain ip dscp != cs1
add rule myIpTable myIpChain ip dscp 1
add rule myIpTable myIpChain ip dscp 0x38
add rule myIpTable myIpChain ip dscp != 0x20
add rule myIpTable myIpChain ip dscp { 1, 2, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21, af22, af23, af31, af32, af33, af41, af42, af43, ef }
add rule myIpTable myIpChain ip dscp { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21, af22, af23, af31, af32, af33, af41, af42, af43, ef }
add rule myIpTable myIpChain ip length 232
add rule MyIpTable myIpChain ip length != 233
add rule MyIpTable myIpChain ip length 333-435
add rule MyIpTable myIpChain ip length != 333-453
add rule MyIpTable myIpChain ip length { 333, 553, 673, 838 }
add rule myIpTable myIpChain ip id 22
add rule myIpTable myIpChain ip id != 233
add rule myIpTable myIpChain ip id 33-45
add rule myIpTable myIpChain ip id != 33-45
add rule myIpTable myIpChain ip id { 33, 55, 67, 88 }
add rule myIpTable myIpChain ip frag-off & 0x1fff != 0  # match fragments
add rule myIpTable myIpChain ip frag-off & 0x2000 != 0  # match MF flag
add rule myIpTable myIpChain ip frag-off & 0x4000 != 0  # match DF flag
add rule myIpTable myIpChain ip ttl 0
add rule myIpTable myIpChain ip ttl 233
add rule myIpTable myIpChain ip ttl 33-55
add rule myIpTable myIpChain ip ttl != 45-50
add rule myIpTable myIpChain ip ttl { 43, 53, 45 }
add rule myIpTable myIpChain ip ttl { 33-55 }
add rule myIpTable myIpChain ip protocol tcp
add rule myIpTable myIpChain ip protocol 6
add rule myIpTable myIpChain ip protocol != tcp
add rule myIpTable myIpChain ip protocol { icmp, esp, ah, comp, udp, udplite, tcp, dccp, sctp }
add rule myIpTable myIpChain ip checksum 13172
add rule myIpTable myIpChain ip checksum 22
add rule myIpTable myIpChain ip checksum != 233
add rule myIpTable myIpChain ip checksum 33-45
add rule myIpTable myIpChain ip checksum != 33-45
add rule myIpTable myIpChain ip checksum { 33, 55, 67, 88 }
add rule myIpTable myIpChain ip checksum { 33-55 }
add rule myIpTable myIpChain ip saddr 192.168.2.0/24
add rule myIpTable myIpChain ip saddr != 192.168.2.0/24
add rule myIpTable myIpChain ip saddr 192.168.3.1 ip daddr 192.168.3.100
add rule myIpTable myIpChain ip saddr != 1.1.1.1
add rule myIpTable myIpChain ip saddr 1.1.1.1
add rule myIpTable myIpChain ip saddr & 0xff == 1
add rule myIpTable myIpChain ip saddr & 0.0.0.255 < 0.0.0.127
add rule myIpTable myIpChain ip daddr 192.168.0.1
add rule myIpTable myIpChain ip daddr != 192.168.0.1
add rule m f ip daddr
add rule myIpTable myIpChain ip daddr 192.168.0.1-192.168.0.250
add rule myIpTable myIpChain ip daddr 10.0.0.0-10.255.255.255
add rule myIpTable myIpChain ip daddr 172.16.0.0-172.31.255.255
add rule myIpTable myIpChain ip daddr 192.168.3.1-192.168.4.250
add rule myIpTable myIpChain ip daddr != 192.168.0.1-192.168.0.250
add rule myIpTable myIpChain ip daddr { 192.168.0.1-192.168.0.250 }
add rule myIpTable myIpChain ip daddr { 192.168.5.1, 192.168.5.2, 192.168.5.3 }
add rule myIpTable myIpChain ip version 4
add rule myIp6Table myIp6Chain ip hdrlength 0
add rule myIp6Table myIp6Chain ip hdrlength 15
add rule myIp6Table myIp6Chain ip6 dscp cs1
add rule myIp6Table myIp6Chain ip6 dscp != cs1
add rule myIp6Table myIp6Chain ip6 dscp 0x38
add rule myIp6Table myIp6Chain ip6 dscp != 0x20
add rule myIp6Table myIp6Chain ip6 dscp { cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, af11, af12, af13, af21, af22, af23, af31, af32, af33, af41, af42, af43, ef }
add rule myIp6Table myIp6Chain ip6 flowlabel 22
add rule myIp6Table myIp6Chain ip6 flowlabel != 233
add rule myIp6Table myIp6Chain ip6 flowlabel { 33, 55, 67, 88 }
add rule myIp6Table myIp6Chain ip6 flowlabel { 33-55 }
add rule myIp6Table myIp6Chain ip6 length 232
add rule myIp6Table myIp6Chain ip6 length != 233
add rule myIp6Table myIp6Chain ip6 length 333-435
add rule myIp6Table myIp6Chain ip6 length != 333-453
add rule myIp6Table myIp6Chain ip6 length { 333, 553, 673, 838 }
add rule myIp6Table myIp6Chain ip6 nexthdr { esp, udp, ah, comp, udplite, tcp, dccp, sctp, icmpv6 }
add rule myIp6Table myIp6Chain ip6 nexthdr esp
add rule myIp6Table myIp6Chain ip6 nexthdr != esp
add rule myIp6Table myIp6Chain ip6 nexthdr { 33-44 }
add rule myIp6Table myIp6Chain ip6 nexthdr 33-44
add rule myIp6Table myIp6Chain ip6 nexthdr != 33-44
add rule myIp6Table myIp6Chain ip6 hoplimit 1
add rule myIp6Table myIp6Chain ip6 hoplimit != 233
add rule myIp6Table myIp6Chain ip6 hoplimit 33-45
add rule myIp6Table myIp6Chain ip6 hoplimit != 33-45
add rule myIp6Table myIp6Chain ip6 hoplimit { 33, 55, 67, 88 }
add rule myIp6Table myIp6Chain ip6 hoplimit { 33-55 }
add rule myIp6Table myIp6Chain ip6 saddr 1234:1234:1234:1234:1234:1234:1234:1234
add rule myIp6Table myIp6Chain ip6 saddr ::1234:1234:1234:1234:1234:1234:1234
add rule myIp6Table myIp6Chain ip6 saddr ::/64
add rule myIp6Table myIp6Chain ip6 saddr ::1 ip6 daddr ::2
add rule myIp6Table myIp6Chain ip6 daddr 1234:1234:1234:1234:1234:1234:1234:1234
add rule myIp6Table myIp6Chain ip6 daddr != ::1234:1234:1234:1234:1234:1234:1234-1234:1234::1234:1234:1234:1234:1234
add rule myIp6Table myIp6Chain ip6 version 6
add rule myInetTable myTcpChain tcp dport 22
add rule myInetTable myTcpChain tcp dport 22 v,
add rule myInetTable myTcpChain tcp dport ppp stuff  # syntax error
add rule myInetTable myTcpChain tcp dport != telnet 
add rule myInetTable myTcpChain tcp dport != 33-45
add rule myInetTable myTcpChain tcp dport { 33-55 }
add rule myInetTable myTcpChain tcp dport { 33, 55, https }
add rule myInetTable myTcpChain tcp dport { telnet, http, https }
add rule myInetTable myTcpChain tcp dport vmap { 22 : accept, 23 : drop }
add rule myInetTable myTcpChain tcp dport vmap { 25:accept, 28:drop }
add rule myInetTable myTcpChain tcp sport 22
add rule myInetTable myTcpChain tcp sport 22-65535 tcp sport sport 1
add rule myInetTable myTcpChain tcp sport != 33-45
add rule myInetTable myTcpChain tcp sport { 33, 55, 67, 88 }
add rule myInetTable myTcpChain tcp sport { 33-55 }
add rule myInetTable myTcpChain tcp sport vmap { 25:accept, 28:drop }
add rule myInetTable myTcpChain tcp sport 1024 tcp dport 22
add rule myInetTable myTcpChain tcp sequence 22
add rule myInetTable myTcpChain tcp sequence != 33-45
add rule myInetTable myTcpChain tcp ackseq 22
add rule myInetTable myTcpChain tcp ackseq != 33-45
add rule myInetTable myTcpChain tcp ackseq { 33, 55, 67, 88 }
add rule myInetTable myTcpChain tcp ackseq { 33-55 }
add rule myInetTable myTcpChain tcp flags { fin, syn, rst, psh, ack, urg, ecn, cwr }
add rule myInetTable myTcpChain tcp flags cwr
add rule myInetTable myTcpChain tcp flags != cwr
add rule myInetTable myTcpChain tcp window 22
add rule myInetTable myTcpChain tcp window != 33-45
add rule myInetTable myTcpChain tcp window { 33, 55, 67, 88 }
add rule myInetTable myTcpChain tcp window { 33-55 }
add rule myInetTable myTcpChain tcp checksum 22
add rule myInetTable myTcpChain tcp checksum != 33-45
add rule myInetTable myTcpChain tcp checksum { 33, 55, 67, 88 }
add rule myInetTable myTcpChain tcp checksum { 33-55 }
add rule myInetTable myTcpChain tcp urgptr 22
add rule myInetTable myTcpChain tcp urgptr != 33-45
add rule myInetTable myTcpChain tcp urgptr { 33, 55, 67, 88 }
add rule myInetTable myTcpChain tcp doff 8
add rule myTable myChain udp dport 22
add rule myTable myChain udp dport != 33-45
add rule myTable myChain udp dport { 33-55 }
add rule myTable myChain udp dport { telnet, http, https }
add rule myTable myChain udp dport vmap { 22 : accept, 23 : drop }
add rule myTable myChain udp dport vmap { 25:accept, 28:drop }
add rule myTable myChain udp sport 22
add rule myTable myChain udp sport != 33-45
add rule myTable myChain udp sport { 33, 55, 67, 88 }
add rule myTable myChain udp sport { 33-55 }
add rule myTable myChain udp sport vmap { 25:accept, 28:drop }
add rule myTable myChain udp sport 1024 udp dport 22
add rule myTable myChain udp length 6666
add rule myTable myChain udp length != 50-65
add rule myTable myChain udp length { 50, 65 }
add rule myTable myChain udp length { 35-50 }
add rule myTable myChain udp checksum 22
add rule myTable myChain udp checksum != 33-45
add rule myTable myChain udp checksum { 33, 55, 67, 88 }
add rule myTable myChain udp checksum { 33-55 }
add rule myTable myChain udplite dport 22
add rule myTable myChain udplite dport != 33-45
add rule myTable myChain udplite dport { 33-55 }
add rule myTable myChain udplite dport { telnet, http, https }
add rule myTable myChain udplite dport vmap { 22 : accept, 23 : drop }
add rule myTable myChain udplite dport vmap { 25:accept, 28:drop }
add rule myTable myChain udplite sport 22
add rule myTable myChain udplite sport != 33-45
add rule myTable myChain udplite sport { 33, 55, 67, 88 }
add rule myTable myChain udplite sport { 33-55 }
add rule myTable myChain udplite sport vmap { 25:accept, 28:drop }
add rule myTable myChain udplite sport 1024 udplite dport 22
add rule myTable myChain udplite checksum 22
add rule myTable myChain udplite checksum != 33-45
add rule myTable myChain udplite checksum { 33, 55, 67, 88 }
add rule myTable myChain udplite checksum { 33-55 }
add rule myTable myChain sctp dport 22
add rule myTable myChain sctp dport != 33-45
add rule myTable myChain sctp dport { 33-55 }
add rule myTable myChain sctp dport { telnet, http, https }
add rule myTable myChain sctp dport vmap { 22 : accept, 23 : drop }
add rule myTable myChain sctp dport vmap { 25:accept, 28:drop }
add rule myTable myChain sctp sport 22
add rule myTable myChain sctp sport != 33-45
add rule myTable myChain sctp sport { 33, 55, 67, 88 }
add rule myTable myChain sctp sport { 33-55 }
add rule myTable myChain sctp sport vmap { 25:accept, 28:drop }
add rule myTable myChain sctp sport 1024 sctp dport 22
add rule myTable myChain sctp checksum 22
add rule myTable myChain sctp checksum != 33-45
add rule myTable myChain sctp checksum { 33, 55, 67, 88 }
add rule myTable myChain sctp checksum { 33-55 }
add rule myTable myChain sctp vtag 22
add rule myTable myChain sctp vtag != 33-45
add rule myTable myChain sctp vtag { 33, 55, 67, 88 }
add rule myTable myChain sctp vtag { 33-55 }
add rule myTable myChain sctp chunk init exists
add rule myTable myChain sctp chunk error missing
add rule myTable myChain sctp chunk init flags 0x1 sctp chunk data tsn 0x23
add rule myTable myChain dccp dport 22
add rule myTable myChain dccp dport != 33-45
add rule myTable myChain dccp dport { 33-55 }
add rule myTable myChain dccp dport { telnet, http, https }
add rule myTable myChain dccp dport vmap { 22 : accept, 23 : drop }
add rule myTable myChain dccp dport vmap { 25:accept, 28:drop }
add rule myTable myChain dccp sport 22
add rule myTable myChain dccp sport != 33-45
add rule myTable myChain dccp sport { 33, 55, 67, 88 }
add rule myTable myChain dccp sport { 33-55 }
add rule myTable myChain dccp sport vmap { 25:accept, 28:drop }
add rule myTable myChain dccp sport 1024 dccp dport 22
add rule myTable myChain dccp type { request, response, data, ack, dataack, closereq, close, reset, sync, syncack }
add rule myTable myChain dccp type request
add rule myTable myChain dccp type != request
add rule myTable myChain ah hdrlength 11-23
add rule myTable myChain ah hdrlength != 11-23
add rule myTable myChain ah hdrlength { 11, 23, 44 }
add rule myTable myChain ah reserved 22
add rule myTable myChain ah reserved != 33-45
add rule myTable myChain ah reserved { 23, 100 }
add rule myTable myChain ah reserved { 33-55 }
add rule myTable myChain ah spi 111
add rule myTable myChain ah spi != 111-222
add rule myTable myChain ah spi { 111, 122 }
add rule myTable myChain ah sequence 123
add rule myTable myChain ah sequence { 23, 25, 33 }
add rule myTable myChain ah sequence != 23-33
add rule myTable myChain esp spi 111
add rule myTable myChain esp spi != 111-222
add rule myTable myChain esp spi { 111, 122 }
add rule myTable myChain esp sequence 123
add rule myTable myChain esp sequence { 23, 25, 33 }
add rule myTable myChain esp sequence != 23-33
add rule myTable myChain comp nexthdr != esp
add rule myTable myChain comp nexthdr { esp, ah, comp, udp, udplite, tcp, tcp, dccp, sctp }
add rule myTable myChain comp flags 0x0
add rule myTable myChain comp flags != 0x33-0x45
add rule myTable myChain comp flags { 0x33, 0x55, 0x67, 0x88 }
add rule myTable myChain comp cpi 22
add rule myTable myChain comp cpi != 33-45
add rule myTable myChain comp cpi { 33, 55, 67, 88 }
add rule myTable myChain icmp type { echo-reply, destination-unreachable, source-quench, redirect, echo-request, time-exceeded, parameter-problem, timestamp-request, timestamp-reply, info-request, info-reply, address-mask-request, address-mask-reply, router-advertisement, router-solicitation }
add rule myTable myChain icmp code 111
add rule myTable myChain icmp code != 33-55
add rule myTable myChain icmp code { 2, 4, 54, 33, 56 }
add rule myTable myChain icmp checksum 12343
add rule myTable myChain icmp checksum != 11-343
add rule myTable myChain icmp checksum { 1111, 222, 343 }
add rule myTable myChain icmp id 12343
add rule myTable myChain icmp id != 11-343
add rule myTable myChain icmp id { 1111, 222, 343 }
add rule myTable myChain icmp sequence 12343
add rule myTable myChain icmp sequence != 11-343
add rule myTable myChain icmp sequence { 1111, 222, 343 }
add rule myTable myChain icmp mtu 12343
add rule myTable myChain icmp mtu != 11-343
add rule myTable myChain icmp mtu { 1111, 222, 343 }
add rule myTable myChain icmp gateway 12343
add rule myTable myChain icmp gateway != 11-343
add rule myTable myChain icmp gateway { 1111, 222, 343 }
add rule myTable myChain icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, echo-request, echo-reply, mld-listener-query, mld-listener-report, mld-listener-reduction, nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, parameter-problem, mld2-listener-report }
add rule myTable myChain icmpv6 code 4
add rule myTable myChain icmpv6 code 3-66
add rule myTable myChain icmpv6 code { 5, 6, 7 }
add rule myTable myChain icmpv6 checksum 12343
add rule myTable myChain icmpv6 checksum != 11-343
add rule myTable myChain icmpv6 checksum { 1111, 222, 343 }
add rule myTable myChain icmpv6 id 12343
add rule myTable myChain icmpv6 id != 11-343
add rule myTable myChain icmpv6 id { 1111, 222, 343 }
add rule myTable myChain icmpv6 sequence 12343
add rule myTable myChain icmpv6 sequence != 11-343
add rule myTable myChain icmpv6 sequence { 1111, 222, 343 }
add rule myTable myChain icmpv6 mtu 12343
add rule myTable myChain icmpv6 mtu != 11-343
add rule myTable myChain icmpv6 mtu { 1111, 222, 343 }
add rule myTable myChain icmpv6 max-delay 33-45
add rule myTable myChain icmpv6 max-delay != 33-45
add rule myTable myChain icmpv6 max-delay { 33, 55, 67, 88 }
add rule myTable myChain ether saddr 00:0f:54:0c:11:04
add rule myTable myChain ether type vlan
add rule myTable myChain dst nexthdr { udplite, ipcomp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp }
add rule myTable myChain dst nexthdr 22
add rule myTable myChain dst nexthdr != 33-45
add rule myTable myChain dst hdrlength 22
add rule myTable myChain dst hdrlength != 33-45
add rule myTable myChain dst hdrlength { 33, 55, 67, 88 }
add rule myTable myChain frag nexthdr { udplite, comp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp, icmp }
add rule myTable myChain frag nexthdr 6
add rule myTable myChain frag nexthdr != 50-51
add rule myTable myChain frag reserved 22
add rule myTable myChain frag reserved != 33-45
add rule myTable myChain frag reserved { 33, 55, 67, 88 }
add rule myTable myChain frag frag-off 22
add rule myTable myChain frag frag-off != 33-45
add rule myTable myChain frag frag-off { 33, 55, 67, 88 }
add rule myTable myChain frag more-fragments 0
add rule myTable myChain frag more-fragments 0
add rule myTable myChain frag id 1
add rule myTable myChain frag id 33-45
add rule myTable myChain hbh nexthdr { udplite, comp, udp, ah, sctp, esp, dccp, tcp, icmpv6 }
add rule myTable myChain hbh nexthdr 22
add rule myTable myChain hbh nexthdr != 33-45
add rule myTable myChain hbh hdrlength 22
add rule myTable myChain hbh hdrlength != 33-45
add rule myTable myChain hbh hdrlength { 33, 55, 67, 88 }
add rule myTable myChain mh nexthdr { udplite, ipcomp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp }
add rule myTable myChain mh nexthdr 22
add rule myTable myChain mh nexthdr != 33-45
add rule myTable myChain mh hdrlength 22
add rule myTable myChain mh hdrlength != 33-45
add rule myTable myChain mh hdrlength { 33, 55, 67, 88 }
add rule myTable myChain mh type { binding-refresh-request, home-test-init, careof-test-init, home-test, careof-test, binding-update, binding-acknowledgement, binding-error, fast-binding-update, fast-binding-acknowledgement, fast-binding-advertisement, experimental-mobility-header, home-agent-switch-message }
add rule myTable myChain mh type home-agent-switch-message
add rule myTable myChain mh type != home-agent-switch-message
add rule myTable myChain mh reserved 22
add rule myTable myChain mh reserved != 33-45
add rule myTable myChain mh reserved { 33, 55, 67, 88 }
add rule myTable myChain mh checksum 22
add rule myTable myChain mh checksum != 33-45
add rule myTable myChain mh checksum { 33, 55, 67, 88 }
add rule myTable myChain rt nexthdr { udplite, ipcomp, udp, ah, sctp, esp, dccp, tcp, ipv6-icmp }
add rule myTable myChain rt nexthdr 22
add rule myTable myChain rt nexthdr != 33-45
add rule myTable myChain rt hdrlength 22
add rule myTable myChain rt hdrlength != 33-45
add rule myTable myChain rt hdrlength { 33, 55, 67, 88 }
add rule myTable myChain rt type 22
add rule myTable myChain rt type != 33-45
add rule myTable myChain rt type { 33, 55, 67, 88 }
add rule myTable myChain rt seg-left 22
add rule myTable myChain rt seg-left != 33-45
add rule myTable myChain rt seg-left { 33, 55, 67, 88 }
add rule myTable myChain vlan id 4094
add rule myTable myChain vlan id 0
add rule myTable myChain vlan cfi 0
add rule myTable myChain vlan cfi 1
add rule myTable myChain vlan pcp 7
add rule myTable myChain vlan pcp 3
add rule myTable myChain arp ptype 0x0800
add rule myTable myChain arp htype 1
add rule myTable myChain arp htype != 33-45
add rule myTable myChain arp htype { 33, 55, 67, 88 }
add rule myTable myChain arp hlen 1
add rule myTable myChain arp hlen != 33-45
add rule myTable myChain arp hlen { 33, 55, 67, 88 }
add rule myTable myChain arp plen 1
add rule myTable myChain arp plen != 33-45
add rule myTable myChain arp plen { 33, 55, 67, 88 }
add rule myTable myChain arp operation { nak, inreply, inrequest, rreply, rrequest, reply, request }
add rule myTable myChain ct state { new, established, related, untracked }
add rule myTable myChain ct state != related
add rule myTable myChain ct state established
add rule myTable myChain ct state 8
add rule myTable myChain ct direction original
add rule myTable myChain ct direction != original
add rule myTable myChain ct direction { reply, original }
add rule myTable myChain ct status expected
add rule myTable myChain (ct status & expected) != expected
add rule myTable myChain ct status { expected, seen-reply, assured, confirmed, snat, dnat, dying }
add rule myTable myChain ct mark 0
add rule myTable myChain ct mark or 0x23 == 0x11
add rule myTable myChain ct mark or 0x3 != 0x1
add rule myTable myChain ct mark and 0x23 == 0x11
add rule myTable myChain ct mark and 0x3 != 0x1
add rule myTable myChain ct mark xor 0x23 == 0x11
add rule myTable myChain ct mark xor 0x3 != 0x1
add rule myTable myChain ct mark 0x00000032
add rule myTable myChain ct mark != 0x00000032
add rule myTable myChain ct mark 0x00000032-0x00000045
add rule myTable myChain ct mark != 0x00000032-0x00000045
add rule myTable myChain ct mark { 0x32, 0x2222, 0x42de3 }
add rule myTable myChain ct mark { 0x32-0x2222, 0x4444-0x42de3 }
add rule myTable myChain ct mark set 0x11 xor 0x1331
add rule myTable myChain ct mark set 0x11333 and 0x11
add rule myTable myChain ct mark set 0x12 or 0x11
add rule myTable myChain ct mark set 0x11
add rule myTable myChain ct mark set mark
add rule myTable myChain ct mark set mark map { 1 : 10, 2 : 20, 3 : 30 }
add rule myTable myChain ct expiration 30
add rule myTable myChain ct expiration 30s
add rule myTable myChain ct expiration != 233
add rule myTable myChain ct expiration != 3m53s
add rule myTable myChain ct expiration 33-45
add rule myTable myChain ct expiration 33s-45s
add rule myTable myChain ct expiration != 33-45
add rule myTable myChain ct expiration != 33s-45s
add rule myTable myChain ct expiration { 33, 55, 67, 88 }
add rule myTable myChain ct expiration { 1m7s, 33s, 55s, 1m28s }
add rule myTable myChain ct helper "ftp"
add rule myTable myChain ct original bytes > 100000
add rule myTable myChain ct bytes > 100000
add rule myTable myChain ct reply packets < 100
add rule myTable myChain ct original ip saddr 192.168.0.1
add rule myTable myChain ct reply ip saddr 192.168.0.1
add rule myTable myChain ct original ip saddr 192.168.1.0/24
add rule myTable myChain ct reply ip saddr 192.168.1.0/24
add rule myTable myChain ct original ip daddr 192.168.0.1
add rule myTable myChain ct reply ip daddr 192.168.0.1
add rule myTable myChain ct original ip daddr 192.168.1.0/24
add rule myTable myChain ct reply ip daddr 192.168.1.0/24
add rule myTable myChain ct original l3proto ipv4
add rule myTable myChain ct original protocol 6
add rule myTable myChain ct original proto-dst 22
add rule myTable myChain ct reply proto-src 53
add rule myTable myChain ct count over 2
add set filter ssh_flood { type ipv4_addr; flags dynamic; }
# which requires an existing ssh_flood set, ie. 
add rule myTable myChain tcp dport 22 add @ssh_flood { ip saddr ct count over 2 } reject
add rule myTable myChain meta iifname "eth0"
add rule myTable myChain meta iifname != "eth0"
add rule myTable myChain meta iifname { "eth0", "lo" }
add rule myTable myChain meta iifname "eth*"
add rule myTable myChain meta oifname "eth0"
add rule myTable myChain meta oifname != "eth0"
add rule myTable myChain meta oifname { "eth0", "lo" }
add rule myTable myChain meta oifname "eth*"
add rule myTable myChain meta iif eth0
add rule myTable myChain meta iif != eth0
add rule myTable myChain meta oif lo
add rule myTable myChain meta oif != lo
add rule myTable myChain meta oif { eth0, lo }
add rule myTable myChain meta iiftype { ether, ppp, ipip, ipip6, loopback, sit, ipgre }
add rule myTable myChain meta iiftype != ether
add rule myTable myChain meta iiftype ether
add rule myTable myChain meta oiftype { ether, ppp, ipip, ipip6, loopback, sit, ipgre }
add rule myTable myChain meta oiftype != ether
add rule myTable myChain meta oiftype ether
add rule myTable myChain meta length 1000
add rule myTable myChain meta length != 1000
add rule myTable myChain meta length > 1000
add rule myTable myChain meta length 33-45
add rule myTable myChain meta length != 33-45
add rule myTable myChain meta length { 33, 55, 67, 88 }
add rule myTable myChain meta length { 33-55, 67-88 }
add rule myTable myChain meta protocol ip
add rule myTable myChain meta protocol != ip
add rule myTable myChain meta protocol { ip, arp, ip6, vlan }
add rule myTable myChain meta nfproto ipv4
add rule myTable myChain meta nfproto != ipv6
add rule myTable myChain meta nfproto { ipv4, ipv6 }
add rule myTable myChain meta l4proto 22
add rule myTable myChain meta l4proto != 233
add rule myTable myChain meta l4proto 33-45
add rule myTable myChain meta l4proto { 33, 55, 67, 88 }
add rule myTable myChain meta l4proto { 33-55 }
add rule myTable myChain meta mark 0x4
add rule myTable myChain meta mark 0x00000032
add rule myTable myChain meta mark and 0x03 == 0x01
add rule myTable myChain meta mark and 0x03 != 0x01
add rule myTable myChain meta mark != 0x10
add rule myTable myChain meta mark or 0x03 == 0x01
add rule myTable myChain meta mark or 0x03 != 0x01
add rule myTable myChain meta mark xor 0x03 == 0x01
add rule myTable myChain meta mark xor 0x03 != 0x01
add rule myTable myChain meta mark set 0xffffffc8 xor 0x16
add rule myTable myChain meta mark set 0x16 and 0x16
add rule myTable myChain meta mark set 0xffffffe9 or 0x16
add rule myTable myChain meta mark set 0xffffffde and 0x16
add rule myTable myChain meta mark set 0x32 or 0xfffff
add rule myTable myChain meta mark set 0xfffe xor 0x16
add rule myTable myChain meta priority none
add rule myTable myChain meta priority 0x1
add rule myTable myChain meta priority 0xffff
####add rule myTable myChain meta priority 0x1:0x1
####add rule myTable myChain meta priority 0x1:0xffff
####add rule myTable myChain meta priority 0xffff:0xffff
####add rule myTable myChain meta priority set 0x1:0x1
####add rule myTable myChain meta priority set 0x1:0xffff
####add rule myTable myChain meta priority set 0xffff:0xffff
add rule myTable myChain meta skuid { bin, root, daemon }
add rule myTable myChain meta skuid root
add rule myTable myChain meta skuid != root
add rule myTable myChain meta skuid lt 3000
add rule myTable myChain meta skuid gt 3000
add rule myTable myChain meta skuid eq 3000
add rule myTable myChain meta skuid 3001-3005
add rule myTable myChain meta skuid != 2001-2005
add rule myTable myChain meta skuid { 2001-2005 }
add rule myTable myChain meta skgid { bin, root, daemon }
add rule myTable myChain meta skgid root
add rule myTable myChain meta skgid != root
add rule myTable myChain meta skgid lt 3000
add rule myTable myChain meta skgid gt 3000
add rule myTable myChain meta skgid eq 3000
add rule myTable myChain meta skgid 3001-3005
add rule myTable myChain meta skgid != 2001-2005
add rule myTable myChain meta skgid { 2001-2005 }
add rule myTable myChain meta rtclassid cosmos
add rule myTable myChain meta pkttype broadcast
add rule myTable myChain meta pkttype != broadcast
add rule myTable myChain meta pkttype { broadcast, unicast, multicast }
add rule myTable myChain meta cpu 1
add rule myTable myChain meta cpu != 1
add rule myTable myChain meta cpu 1-3
add rule myTable myChain meta cpu != 1-2
add rule myTable myChain meta cpu { 2,3 }
add rule myTable myChain meta cpu { 2-3, 5-7 }
add rule myTable myChain meta iifgroup 0
add rule myTable myChain meta iifgroup != 0
add rule myTable myChain meta iifgroup default
add rule myTable myChain meta iifgroup != default
add rule myTable myChain meta iifgroup { default }
add rule myTable myChain meta iifgroup { 11,33 }
add rule myTable myChain meta iifgroup { 11-33 }
add rule myTable myChain meta oifgroup 0
add rule myTable myChain meta oifgroup != 0
add rule myTable myChain meta oifgroup default
add rule myTable myChain meta oifgroup != default
add rule myTable myChain meta oifgroup { default }
add rule myTable myChain meta oifgroup { 11,33 }
add rule myTable myChain meta oifgroup { 11-33 }
add rule myTable myChain meta cgroup 1048577
add rule myTable myChain meta cgroup != 1048577
add rule myTable myChain meta cgroup { 1048577, 1048578 }
add rule myTable myChain meta cgroup 1048577-1048578
add rule myTable myChain meta cgroup != 1048577-1048578
add rule myTable myChain meta cgroup { 1048577-1048578 }
add rule myTable myChain log
add rule myTable myChain log level emerg
add rule myTable myChain log level alert
add rule myTable myChain log level crit
add rule myTable myChain log level err
add rule myTable myChain log level warn
add rule myTable myChain log level notice
add rule myTable myChain log level info
add rule myTable myChain log level debug
add rule myTable myChain log prefix aaaaa-aaaaaa group 2 snaplen 33
add rule myTable myChain log group 2 queue-threshold 2
add rule myTable myChain log group 2 snaplen 33
add rule myTable myChain reject
add rule myTable myChain reject with icmp type host-unreachable
add rule myTable myChain reject with icmp type net-unreachable
add rule myTable myChain reject with icmp type prot-unreachable
add rule myTable myChain reject with icmp type port-unreachable
add rule myTable myChain reject with icmp type net-prohibited
add rule myTable myChain reject with icmp type host-prohibited
add rule myTable myChain reject with icmp type admin-prohibited
add rule myTable myChain reject with icmpv6 type no-route
add rule myTable myChain reject with icmpv6 type admin-prohibited
add rule myTable myChain reject with icmpv6 type addr-unreachable
add rule myTable myChain reject with icmpv6 type port-unreachable
add rule myTable myChain reject with icmpx type host-unreachable
add rule myTable myChain reject with icmpx type no-route
add rule myTable myChain reject with icmpx type admin-prohibited
add rule myTable myChain reject with icmpx type port-unreachable
add rule myTable myChain ip protocol tcp reject with tcp reset
add rule myTable myChain counter
add rule myTable myChain counter packets 0 bytes 0
add rule myTable myChain limit rate 400/minute
add rule myTable myChain limit rate 400/hour
add rule myTable myChain limit rate over 40/day
add rule myTable myChain limit rate over 400/week
add rule myTable myChain limit rate over 1023/second burst 10 packets
add rule myTable myChain limit rate 1025 kbytes/second
add rule myTable myChain limit rate 1023000 mbytes/second
add rule myTable myChain limit rate 1025 bytes/second burst 512 bytes
add rule myTable myChain limit rate 1025 kbytes/second burst 1023 kbytes
add rule myTable myChain limit rate 1025 mbytes/second burst 1025 kbytes
add rule myTable myChain limit rate 1025000 mbytes/second burst 1023 mbytes
add rule myTable myChain dnat to 192.168.3.2
add rule myTable myChain dnat to ct mark map { 0x00000014 : 1.2.3.4 }
add rule myTable myChain snat to 192.168.3.2
add rule myTable myChain snat to 2001:838:35f:1::-2001:838:35f:2:::100
add rule myTable myChain masquerade
add rule myTable myChain masquerade persistent,fully-random,random
add rule myTable myChain masquerade to :1024
add rule myTable myChain masquerade to :1024-2048
add rule myTable myChain queue
add rule myTable myChain queue num 2
add rule myTable myChain queue num 2-3
add rule myTable myChain queue num 4-5 fanout bypass
add rule myTable myChain queue num 4-5 fanout
add rule myTable myChain queue num 4-5 bypass
add rule ip filter input tcp dport { 22, 80, 443 } counter
add rule ip myIpTable myIpChain accept
###add rule ip myIpTable myIpChain { type filter hook input priority 0; policy drop;}
add rule ip filter input ip daddr @blackhole counter accept
add rule netdev myNetdevTable myNetdevChain fwd to eth1
add rule bridge myBridgeTable myBridgeChain jump BridgeSpan
add rule arp myArpTable myArpChain jump ArpProxy
add rule ip myIpTable myIpChain accept
add rule ip myIpTable myIpChain tcp dport 23 accept;
add rule ip myIpTable myIpChain tcp dport { 22, http, 443 } accept
add rule inet mytable myin jump nuts
add rule inet mytable myin counter jump nuts;
add rule inet mytable myin jump toMe accept;
add rule inet mytable myin counter accept
add rule inet mytable myin counter accept comment "foo bar"
add rule ip filter output ip daddr 192.168.0.0/24 accept
add rule bridge filter forward ether type ip tcp dport 22 accept
add rule bridge filter forward ether type arp accept
add rule inet nat prerouting dnat ip to 10.0.2.99
add rule inet nat prerouting dnat ip6 to fe80::dead
add rule inet nat postrouting meta oif ppp0 masquerade
add rule ip filter input meta iifname "internal" accept
add rule ip filter input ip saddr @blackhole counter drop
###add rule inet mytable myin counter comment "foo bar" accept  # comment is too early
add rule ip filter input tcp flags syn tcp dport ssh meter flood size 128000 { ip saddr timeout 10s limit rate over 10/second} add @blackhole { ip saddr timeout 1m } drop
add rule ip nat prerouting dnat tcp dport map { 80 : 192.168.1.100, 8888 : 192.168.1.101 }
add rule ip nat postrouting snat to ip saddr map { 192.168.1.0/24 : 10.0.0.1, 192.168.2.0/24 : 10.0.0.2 }
add rule ip filter input ip protocol vmap { tcp : jump tcp-chain, udp : jump udp-chain , icmp : jump icmp-chain }


#    add rule <family> <table_id> <chain_id> position <num> ...
add rule ip myIpTable myIpChain position 5 accept
#    add rule <family> <table_id> <chain_id> handle <num> ...
#    add rule <family> <table_id> <chain_id> index <num> ...
#

# Implicit 'rule' RULE (without the 'rule' keyword nor 'add rule' keyphrase))
#    add <table_id> <chain_id> ...
add myIpTable myIpChain accept

#    add <table_id> <chain_id> position 7 ...
add myIpTable myIpChain position 5 accept

#    add <table_id> <chain_id> handle 42 ...
add myIpTable myIpChain handle 5 accept

#    add <table_id> <chain_id> index 123 ...
add myIpTable myIpChain index 5 accept

#    add <family> <table_id> <chain_id> ...
add ip myIpTable myIpChain accept

#    add <family> <table_id> <chain_id> position <num> ...
#
#    add <family> <table_id> <chain_id> handle <num> ...
add ip myIpTable myIpChain handle 5 accept

####add rule myIpTable myChain { type filter hook input priority 0; policy drop;}

# add set_cmd 
# BISON: ADD SET set_spec set_block_alloc { set_block }
add set myIpTable mySet { type mark; flags interval; timeout 15m; gc-interval 2d; size 1200; policy memory; auto-merge; }
add set filter blackhole { type ipv4_addr ; }
add set filter set1 { type ipv4_addr ; policy memory ; }
add set filter set1 { type ipv4_addr ; policy performance ; }
add set ip myIpTable mySet {   # comment
    type inet_proto;   # comment
    flags interval;   # comment
    timeout 30s;   # comment
    gc-interval 2h;   # comment
    elements = {ip};   # comment
    size 1200;   # comment
    policy memory;   # comment
    auto-merge;   # comment
    };  # comment
add set netdev myNetdevTable myNetdevSet { type ether_addr; flags interval; timeout 15m; gc-interval 2d; size 1200; policy performance; auto-merge; }
###add set netdev myNetdevTable myNetdevSet { type ether_addr; flags interval; timeout 15m; gc-interval 2d; elements = {mark}; size 1200; policy performance; auto-merge; } # elements = {mark}; not available yet.
add set bridge myBridgeTable myBridgeSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ether_addr}; size 1200; policy memory; auto-merge; }
add set arp myArpTable myArpSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ipv4_addr}; size 1200; policy performance; auto-merge; }
add set ip myIpTable myIpSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ipv4_addr}; size 1200; policy memory; auto-merge; }
add set ip6 myIp6Table myIp6Set { type inet_service; flags interval; timeout 15m; gc-interval 2d; elements = {ipv6_addr}; size 1200; policy memory; auto-merge; }
add set inet myInetTable myInetSet { type mark; flags interval; timeout 15m; gc-interval 2d; elements = {ipv4_addr,ipv6_addr}; size 1200; policy performance; auto-merge; }
add set ip filter blackhole { type ipv4_addr; flags timeout; size 65536; }

# add set <set_spec> { <set_block> }
add set my_filter_table my_ssh_meter { type ipv4_addr . inet_proto; flags dynamic ;}
add set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags timeout;}
###add set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags timeout . dynamic ;}  # 'flags timeout . dynamic' not available yet

# add map set_spec map_block_alloc { map_block }
# Bison: ADD MAP set_spec { map_block }
add rule route output mark set 123  # placeholde for 'add map' entries
add map myNetdevTable myNetdevMap { flags interval; elements = { ether_addr }; size 1200; policy performance; }
add map arp myArpTable myArpMap { flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
###add map arp myArpTable myArpMap { type mark; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }  # 'type mark' nor 'type mark 5' is available yet
add map ip myIpTable myIpMap { type inet_service: ipv4_addr; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
###add map ip6 myIp6Table myIp6Map { type mark; flags interval; elements = { ipv6_addr }; size 1200; policy performance; }  # 'type mark' nor 'type mark 5' is available yet
add map ip6 myIp6Table myIp6Map { flags interval; elements = { ipv6_addr }; size 1200; policy performance; }
###add map inet myInetTable myInetMap { type mark; flags interval; elements = { inet_proto }; size 1200; policy performance; }  # 'type mark' nor 'type mark 5' is available yet
add map inet myInetTable myInetMap { flags interval; elements = { inet_proto }; size 1200; policy performance; }
###add map netdev myNetdevTable myNetdevMap { type mark; flags interval; elements = { ether_addr }; size 1200; policy performance; }
add map netdev myNetdevTable myNetdevMap { flags interval; elements = { ether_addr }; size 1200; policy performance; }
###add map bridge myBridgeTable myBridgeMap { type mark; flags interval; elements = { ether_addr }; size 1200; policy performance; }
add map bridge myBridgeTable myBridgeMap { flags interval; elements = { ether_addr }; size 1200; policy performance; }
add map filter whitelist { type ipv4_addr . inet_service : ipv6_addr; }
add map filter ports { type inet_service : ipv4_addr ; }
###add map myIpTable myIpMap { type mark : 5; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }  # 'type mark : 5' is not available yet


# add element set_spec set_block_expr
# Bison: ADD ELEMENT set_spec set_block_expr
add set myTable myset {
    type inet_service
    flags timeout
    elements = { http expires 9s};
};
add element filter blackhole { 192.168.0.1, 192.168.0.10 };
add element inet myfilter myset {10.0.0.1 timeout 10s };
add element netdev myNetdevTable myNetdevMap { 1.2.3.4 timeout 5s };
####add element netdev myNetdevTable myNetdevMap { elements = { ether_addr } ; }  # 'elements = {}' N/A
add element bridge myBridgeTable myBridgeMap { 2.2.2.2 timeout 3h }
####add element bridge myBridgeTable myBridgeMap { elements = { ether_addr } ; }
add element arp myArpTable myArpMap { 3.3.3.3 timeout 1d }
####add element arp myArpTable myArpMap { elements = { ipv4_addr } ; }
add element ip myIpTable myIpMap { 4.4.4.4 timeout 8d }
add element ip6 myIp6Table myIp6Map { 5.5.5.5 timeout 60m }
add element inet myInetTable myInetMap { 6.6.6.6 timeout 24h }
add element filter ports { 80 : "http-quota" }
add element filter ports { 22 : "ssh-quota" }
add element ip myIpTable myTestMap { 10.11.1.15 : jump test_1_15 }
add element filter blackhole { 10.2.3.4, 10.23.1.42 };

# add flowtable <flowtable_spec> { <flowtable_block> }
add flowtable myIpTable myIpFT { hook input priority 0; devices = $MYDEVICE ; }
add flowtable myIpTable myIpFT { hook input priority 0; devices = { eth1, eth0 } ; }
add flowtable ip myIpTable myIpFT { hook input priority 0; devices = { eth0, eth1 } ; }
add flowtable ip6 myIp6Table myIp6FT { hook input priority 0; devices = { eth1, eth0 } ; }
add flowtable inet myInetTable myInetFT { hook input priority 0; devices = { eth1, eth1 } ; }

# add counter <obj_spec>
add counter obj_spec close_scope_counter
# Bison: ADD COUNTER obj_spec counter_obj counter_config close_scope_counter
add counter myIpTable https-filter
add counter netdev myNetdevTable https-filter  
add counter bridge myBridgeTable https-filter  
add counter arp myArpTable https-filter  
add counter ip myIpTable https-filter  
add counter ip6 myIp6Table https-filter  
add counter inet myInetTable https-filter  
# add counter <obj_spec> <counter_obj>  # TBD
add counter myIpTable https-filter
add counter netdev myNetdevTable https-filter  
add counter bridge myBridgeTable https-filter  
add counter arp myArpTable https-filter  
add counter ip myIpTable https-filter  
add counter ip6 myIp6Table https-filter  
add counter inet myInetTable https-filter  
# Bison: ADD COUNTER obj_spec counter_obj counter_config { counter_block } close_scope_counter

# add quota <obj_spec> <quota_odj>
# Bison: ADD QUOTA <obj_spec> <quota_odj>
add quota filter http-quota over 25 mbytes
add quota netdev myIpfilter http-quota over 25 mbytes;
add quota bridge myIpfilter http-quota over 25 mbytes
add quota arp myIpfilter http-quota over 25 mbytes
add quota ip myIpfilter http-quota over 25 mbytes
add quota ip6 myIpfilter http-quota until 525 kbytes
add quota inet myIpfilter http-quota over 25 mbytes
# Bison: ADD QUOTA obj_spec quota_obj quota_config { quota_block } close_scope_quota
add quota filter http-quota { over 25 mbytes };
add quota filter ssh-quota { 10 kbytes }

# add ct helper <obj_spec> { <ct_helper_block> }
# add ct helper <table_spec> <chain_id> { <ct_helper_block> }
# add ct helper <family_spec> <table_id> <chain_id> { <ct_helper_block> }
# add ct helper <obj_spec> { }
# add ct helper <obj_spec> { <common_block> }
# add ct helper <obj_spec> { <include> }
# add ct helper <obj_spec> { <define> }
# add ct helper <obj_spec> { <redefine> }
# add ct helper <obj_spec> { <undefine> }
# add ct helper <obj_spec> { <stmt_separator> }
# add ct helper <obj_spec> { <ct_helper_config> }
# add ct helper <obj_spec> { type <quoted_str> protocol <ct_l4protoname> }
add ct helper myIpTable myCTHchain { };
add ct helper myIpTable myCTHchain { ; }
add ct helper myIpTable myCTHchain { ; };
add ct helper myIpTable myCTHchain { type "sip" protocol tcp; l3proto ip; }
add ct helper ip myIpTable cth { type "sip" protocol tcp; l3proto ip; }

# add ct timeout obj_spec ct_obj_alloc { ct_timeout_block } close_scope_ct
# Bison: ADD CT timeout myTimeout { .... }
# Bison: ADD CT TIMEOUT obj_spec ct_obj_alloc { ct_timeout_block } close_scope_ct
add ct timeout myIpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
add ct timeout netdev myNetdevTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
add ct timeout bridge myBridgeTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
add ct timeout arp myArpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
add ct timeout ip myIpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
add ct timeout ip6 myIp6Table ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
add ct timeout inet myInetTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }

# Bison: ADD CT EXPECTATION obj_spec ct_obj_alloc { ct_expect_block } close_scope_ct
add ct expectation myTable myCHain { ; } 
add ct expectation myTable e_pgsql {
        protocol tcp
        dport 5432
        timeout 1h
        size 12
        l3proto ip
    }

# add limit <obj_spec> <limit_obj>
# add limit obj_spec limit_obj limit_config close_scope_limit
# add limit obj_spec limit_obj { limit_block } close_scope_limit
add limit myIpTable myIpLimit rate 1/second 
add limit netdev myNetdevTable myNetdevLimit rate 1/minute 
add limit bridge myBridgeTable myBridgeLimit rate 1 /hour 
add limit ip myIpTable myIpLimit rate 1/ day
add limit ip6 myIp6Table myIp6Limit rate 1 / week
add limit inet myInetTable myInetLimit rate 1/second
add limit myIpTable myIpLimit rate 1/second burst 15 packets
####add limit myIpTable myIpLimit rate 1/second burst 1514 bytes  # 'burst 1514 bytes' N/A

# Bison: SECMARK obj_spec secmark_obj secmark_config { secmark_block } close_scope_secmark 
add secmark myTable myTable mySecMark 
# Bison: SECMARK obj_spec secmark_obj secmark_config { common_block } close_scope_secmark 
add secmark myTable sshtag { "system_u:object_r:ssh_server_packet_t:s0" }

#   add synproxy obj_spec synproxy_obj synproxy_config close_scope_synproxy (without the 'add' keyword)
#   Bison: ADD SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy 
add synproxy myTable synproxy_obj mss 1500 wscale 7;
add synproxy ip myTable synproxy_obj mss 1492 wscale 5;
add synproxy ip6 myTable synproxy_obj mss 1498 wscale 6;
add synproxy inet myTable synproxy_obj mss 1496 wscale 4;
add synproxy arp myTable synproxy_obj mss 1512  wscale 2;
add synproxy bridge myTable synproxy_obj mss 1518 wscale 3;
add synproxy netdev myTable synproxy_obj mss 1593 wscale 1
#   Bison: SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy (w/o 'add')
#   Bison: SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy (w/o 'add')
add synproxy myTable https-synproxy {
    mss 1460
    wscale 7
    timestamp sack-perm
}
add synproxy myTable other-synproxy {
    mss 1460
    wscale 5
}


# REPLACE (replace_cmd)
# REPLACE rule [<family>] <table> <chain> [handle <handle>] <matches> <statements>
# Bison: replace ruleid_spec(chain_spec handle_spec) rule
replace rule ip myTable myChain handle 1 counter

# Section: base_cmd/ADD/CREATE
# CREATE (create_cmd)
#  create is similar to the add command, but returns 
#  an error if the chain already exists.
create table myIpTable 
create table bridge myBridge  
create table arp myArpTable  
create table ip myIpTable  
create table ip6 myIp6Table  
create table inet myInetTable  
create table myIpTable { flags dormant; } 
create table netdev myNetdev { flags dormant; }
create table bridge myBridge { flags dormant; }
create table arp myArpTable { flags dormant; }
create table ip myIpTable { flags dormant; }
create table ip6 myIp6Table { flags dormant; }
create table inet myInetTable { flags dormant; }

create table myIpTable  
create table ipX myIpTable  # incorrect family_spec
create table ip myIpTable
create table ip6 myNetdev
create table inet myNetdev
create table netdev myNetdev
create table bridge myNetdev
create table arp myNetdev
create table arp ; myNetdev   # premature semicolon
create table arp myArp


# Two kinds of a base chain for syntax handling:
#  1. Unidentified family chain
#  2. Explictly-identified family chain

# create chain <chain_spec>
create chain myIpTable myIpChain
create chain netdev myNetdevTable myNetdevTable 
create chain bridge myBridgeTable myBridgeChain 
create chain arp myArpTable myArpChain 
create chain ip myIpTable myIpChain 
create chain ip6 myIp6Table myIp6Chain 
create chain inet myInetTable myInetChain 

# create chain <chain_spec> { <chain_block> }
create chain myIpTable myIpChain { type filter hook prerouting priority 0; policy drop; } ;
create chain myIpTable myIpChain { type filter hook input priority 0; policy drop;};
create chain myIpTable myIpChain { type filter hook forward priority 0; policy drop;}
create chain myIpTable myIpChain { type filter hook output priority 0; policy drop;}
create chain myIpTable myIpChain { type filter hook postrouting priority 0; policy drop;}
create chain myIpTable myIpChain { type filter hook input device eth0 priority 0; policy drop;}
create chain arp myArpTable myArpChain { type filter hook input priority 0; policy accept; }
create chain arp myArpTable myArpChain { type filter hook input priority 0; policy accept; }
create chain arp myArpTable myArpChain { type filter hook output priority 0; policy accept; }
create chain arp myArpTable myArpChain { type filter hook input device eth0 priority 0; policy accept; }
create chain bridge myBridgeTable myBridgeChain { type filter hook input priority 0; policy accept; }
create chain bridge myBridgeTable myBridgeChain { type filter hook output priority 0; policy accept; }
create chain bridge myBridgeTable myBridgeChain { type filter hook input device eth0 priority 0; policy accept; }
create chain netdev myNetdevTable myNetdevChain 
create chain netdev myNetdevTable myNetdevChain { type filter hook ingress device vlan0 priority 0; policy accept; }
create chain ip myIpTable myIpChain { type filter hook prerouting priority 0; policy accept; }
create chain ip myIpTable myIpChain { type filter hook input priority 0; policy accept; }
create chain ip myIpTable myIpChain { type filter hook forward priority 0; policy accept; }
create chain ip myIpTable myIpChain { type filter hook output priority 0; policy accept; }
create chain ip myIpTable myIpChain { type filter hook postrouting priority 0; policy accept; }
create chain ip myIpTable myIpChain { type nat hook prerouting priority 0; policy accept; }
create chain ip myIpTable myIpChain { type nat hook input priority 0; policy accept; }
create chain ip myIpTable myIpChain { type nat hook output priority 0; policy accept; }
create chain ip myIpTable myIpChain { type nat hook postrouting priority 0; policy accept; }
create chain ip myIpTable myIpChain { type route hook output priority 0; policy accept; }

create chain ip myIpTable myIpChain { type filter hook input device eth0 priority 0; policy accept; }

create chain ip6 myIp6Table myIp6Chain { type filter hook prerouting priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type filter hook input priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type filter hook forward priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type filter hook output priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type filter hook postrouting priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type nat hook prerouting priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type nat hook input priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type nat hook output priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type nat hook postrouting priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type route hook output priority 0; policy accept; }
create chain ip6 myIp6Table myIp6Chain { type filter hook input device eth0 priority 0; policy accept; }
create chain inet myInetTable myInetChain { type filter hook prerouting priority 0; policy accept; }
create chain inet myInetTable myInetChain { type filter hook input priority 0; policy accept; }
create chain inet myInetTable myInetChain { type filter hook forward priority 0; policy accept; }
create chain inet myInetTable myInetChain { type filter hook output priority 0; policy accept; }
create chain inet myInetTable myInetChain { type filter hook postrouting priority 0; policy accept; }
create chain inet myInetTable myInetChain { type nat hook prerouting priority 0; policy accept; }
create chain inet myInetTable myInetChain { type nat hook input priority 0; policy accept; }
create chain inet myInetTable myInetChain { type nat hook output priority 0; policy accept; }
create chain inet myInetTable myInetChain { type nat hook postrouting priority 0; policy accept; }
create chain inet myInetTable myInetChain { type route hook output priority 0; policy accept; }
create chain inet myInetTable myInetChain { type filter hook input device eth0 priority 0; policy accept; }

create chain netdev myIpTable myIpChain { type filter hook ingress devices = { eth0, eth1, eth2 } priority 0; policy drop;}
create chain bridge myBridgeTable myBridgeChain { type filter hook prerouting devices = { eth0, eth1, eth2 } priority 0; policy drop;}
create chain arp myArpTable myArpChain { type filter hook input devices = { eth0, eth1, eth2 } priority 0; policy drop;}
create chain ip myIpTable myIpChain { type nat hook postrouting devices = { eth0, eth1, eth2 } priority 0; policy drop;}
create chain ip6 myIp6Table myIp6Chain { type filter hook input devices = { eth0, eth1, eth2 } priority 0; policy drop;}
create chain inet myInetTable myInetChain { type route hook output devices = { eth0, eth1, eth2 } priority 0; policy drop;}

# create set <set_spec> { <set_block> }
create set my_filter_table my_ssh_meter { type ipv4_addr . inet_proto; flags dynamic ;}
create set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags timeout;}
####create set my_filter_table my_ssh_meter { type ipv4_addr . inet_service; flags timeout . dynamic ;}

# create map <set_spec> { <map_block> }
create map myIpTable myIpMap { flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
####create map myIpTable myIpMap { type mark : 5; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
create map netdev myNetdevTable myNetdevMap { flags interval; elements = { ether_addr }; size 1200; policy performance; }
####create map netdev myNetdevTable myNetdevMap { type mark; flags interval; elements = { ether_addr }; size 1200; policy performance; }
create map bridge myBridgeTable myBridgeMap { flags interval; elements = { ether_addr }; size 1200; policy performance; }
####create map bridge myBridgeTable myBridgeMap { type mark; flags interval; elements = { ether_addr }; size 1200; policy performance; }
create map arp myArpTable myArpMap { flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
####create map arp myArpTable myArpMap { type mark; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
create map ip myIpTable myIpMap { type inet_service: ipv4_addr; flags interval; elements = { ipv4_addr }; size 1200; policy performance; }
create map ip6 myIp6Table myIp6Map { flags interval; elements = { ipv6_addr }; size 1200; policy performance; }
####create map ip6 myIp6Table myIp6Map { type mark; flags interval; elements = { ipv6_addr }; size 1200; policy performance; }
create map inet myInetTable myInetMap { flags interval; elements = { inet_proto }; size 1200; policy performance; }
####create map inet myInetTable myInetMap { type mark; flags interval; elements = { inet_proto }; size 1200; policy performance; }

# create element <set_spec> <set_block_expr>
#create element myIpTable myIpSet { element, element }
create element netdev myNetdevTable myNetdevSet { 10.20.255.48/29 : goto group_114, 10.20.255.88/29 : goto group_114, 10.20.255.128/29 : goto group_114 } 
create element bridge myBridgeTable myBridgeSet { 8.8.8.8, 8.8.4.4 }
create element arp myArpTable myArpSet { 10.20.255.50 : 1:ffd8, 10.20.255.90 : 1:ffd5, 10.20.255.130 : 1:ffd2 }
create element ip myIpTable myIpSet { 10.20.255.88/29 : goto group_114 }
create element ip6 myIp6Table myIp6Set { 10.20.255.128/29 : goto group_114 }
create element inet myInetTable myInetSet { 10.20.255.50/32 : "1:0xffd9" }

# create flowtable <flowtable_spec> { <flowtable_block> }
create flowtable myIpTable myIpFT { hook input priority 0; devices = { br0, eth0, eth1} ; }
create flowtable ip myIpTable myIpFT { hook input priority 0; devices = { eth0, eth1 } ; }
create flowtable ip6 myIp6Table myIp6FT { hook input priority 0; devices = { br0, eth0 } ; }
create flowtable inet myInetTable myInetFT { hook input priority 0; devices = { br0, eth1 } ; }

# create counter <obj_spec> close_scope_counter 
# create counter <obj_spec> counter_obj counter_config close_scope_counter  
create counter myIpTable https-filter
create counter netdev myNetdevTable https-filter  
create counter bridge myBridgeTable https-filter  
create counter arp myArpTable https-filter  
create counter ip myIpTable https-filter  
create counter ip6 myIp6Table https-filter  
create counter inet myInetTable https-filter  

# create quota <obj_spec> <quota_odj> <quota_config>
create quota filter http-quota over 25 mbytes
###create quota filter http-quota { over 25 mbytes };
###create quota filter ssh-quota { 10 kbytes }
create quota netdev myIpfilter http-quota over 25 mbytes;
create quota bridge myIpfilter http-quota over 25 mbytes
create quota arp myIpfilter http-quota over 25 mbytes
create quota ip myIpfilter http-quota over 25 mbytes
create quota ip6 myIpfilter http-quota until 525 kbytes
create quota inet myIpfilter http-quota over 25 mbytes

# create ct helper  obj_spec ct_obj_alloc { ct_helper_block } close_scope_ct
create ct helper myIpTable myCTHchain { };
create ct helper myIpTable myCTHchain { ; }
create ct helper myIpTable myCTHchain { ; };
create ct helper myIpTable myCTHchain { type "sip" protocol tcp; l3proto ip; }
create ct helper ip myIpTable cth { type "sip" protocol tcp; l3proto ip; }

# create ct timeout  obj_spec ct_obj_alloc { ct_timeout_block } 
create ct timeout myIpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout netdev myNetdevTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout bridge myBridgeTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout arp myArpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout ip myIpTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout ip6 myIp6Table ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout inet myInetTable ctt { protocol udp; l3proto ip; policy = { unreplied : 15, replied : 12 }; }
create ct timeout myTable agressive-tcp {
        l3proto ip;
        protocol tcp;
        policy = {established: 100, close_wait: 4, close: 4}
    }

# create ct expectation  obj_spec ct_obj_alloc { ct_expect_block } close_scope_ct
create ct expectation myTable myExpectation { ; }
create ct expectation myTable myExpectation { ; } 
create ct expectation myTable e_pgsql {
        protocol tcp
        dport 5432
        timeout 1h
        size 12
        l3proto ip
    }


# create limit <obj_spec> <limit_obj> <limit_config>
create limit myIpTable myIpLimit rate 1/second
create limit netdev myNetdevTable myNetdevLimit rate 1/minute
create limit bridge myBridgeTable myBridgeLimit rate 1/hour
create limit ip myIpTable myIpLimit rate 1/day
create limit ip6 myIp6Table myIp6Limit rate 1/week
create limit inet myInetTable myInetLimit rate 1/second
create limit myIpTable myIpLimit rate 1/second burst 15 packets
###create limit myIpTable myIpLimit rate 1/second burst 1514 bytes

# create secmark obj_spec secmark_obj secmark_config close_scope_secmark
# Bison: CREATE SECMARK obj_spec secmark_obj secmark_config { secmark_block } close_scope_secmark 
create secmark myTable myTable mySecMark 
# Bison: CREATE SECMARK obj_spec secmark_obj secmark_config { common_block } close_scope_secmark 
####create secmark myTable sshtag { "system_u:object_r:ssh_server_packet_t:s0" }

# create synproxy obj_spec synproxy_obj synproxy_config close_scope_synproxy
#   Bison: ADD SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy 
create synproxy myTable synproxy_obj mss 1500 wscale 7;
create synproxy ip myTable synproxy_obj mss 1492 wscale 5;
create synproxy ip6 myTable synproxy_obj mss 1498 wscale 6;
create synproxy inet myTable synproxy_obj mss 1496 wscale 4;
create synproxy arp myTable synproxy_obj mss 1512  wscale 2;
create synproxy bridge myTable synproxy_obj mss 1518 wscale 3;
create synproxy netdev myTable synproxy_obj mss 1593 wscale 1
#   Bison: SYNPROXY obj_spec synproxy_obj synproxy_config { common_block } close_scope_synproxy (w/o 'add')
###create synproxy myTable https-synproxy {
###    mss 1460
###    wscale 7
###    timestamp sack-perm
###}
###create synproxy myTable other-synproxy {
###    mss 1460
###    wscale 5
###}

# insert_cmd
insert rule filter output ip daddr 192.168.0.0/24 accept # 'ip filter' is assumed

# delete_cmd
# delete table <table_spec>
delete table myIpTable
delete table netdev myNetdevTable
delete table bridge myBridgeTable
delete table arp myArpTable
delete table ip myIpTable
delete table ip6 myIp6Table
delete table inet myInetTable
# delete table <tableid_spec>
delete table netdev handle 123
delete table handle 4321  # comment

delete chain table_name chain_name
delete chain ip table_name chain_name
delete chain ip6 table_name chain_name
delete chain inet table_name chain_name
delete chain arp table_name chain_name
delete chain bridge table_name chain_name
delete chain netdev table_name chain_name
delete chain table_name handle 15
delete chain ip table_name handle 15
delete chain ip6 table_name handle 15
delete chain inet table_name handle 15
delete chain arp table_name handle 15
delete chain bridge table_name handle 15
delete chain netdev table_name handle 15

# delete rule <ruleid_spec>
delete rule myInetTable myChain handle 42
delete rule ip myInetTable myChain handle 42
delete rule ip6 table_name chain_name handle 16
delete rule inet table_name chain_name handle 16
delete rule arp table_name chain_name handle 16
delete rule bridge table_name chain_name handle 16
delete rule netdev table_name chain_name handle 16

# delete set <set_spec>
delete set myIpTable myIpSet
delete set netdev myNetdevTable mySet
delete set bridge myBridgeTable myBridgeSet
delete set arp myArpTable myArpSet
delete set ip myIpTable myIpSet
delete set ip6 myIp6Table myIp6Set
delete set inet myInetTable myInetSet
# delete set <setid_spec>
delete set myIpTable handle 123
delete set ip myIpTable handle 123
delete set inet myInetTable handle 42 # comment

# delete map <set_spec>
delete map myIpTable myIpMap 
delete map netdev myNetdevTable myNetdevMap 
delete map bridge myBridgeTable myBridgeMap 
delete map arp myArpTable myArpMap 
delete map ip myIpTable myIpMap 
delete map ip6 myIp6Table myIp6Map 
delete map inet myInetTable myInetMap 

# delete element <set_spec> <set_block_expr>
delete element inet myfilter myset { 10.0.0.1 }
delete element netdev myNetdevTable myNetdevSet { 10.0.0.1, 127.0.0.1 }
delete element bridge myBridgeTable myBridgeSet { 4.4.4.4 }
delete element arp myArpTable myArpSet { 4.4.4.4 }
delete element ip myIpTable myIpSet { 4.4.4.4 }
delete element ip6 myIp6Table myIp6Set { 4.4.4.4 }
delete element inet myInetTable myInetSet { 4.4.4.4 }
delete element myIpTable myIpMap { 4.4.4.4 }
delete element netdev myNetdevTable myNetdevMap { 4.4.4.4 }
delete element bridge myBridgeTable myBridgeMap { 4.4.4.4 }
delete element arp myArpTable myArpMap { 4.4.4.4 }
delete element ip myIpTable myIpMap { 4.4.4.4 }
delete element ip6 myIp6Table myIp6Map { 4.4.4.4 }
delete element inet myInetTable myInetMap { 4.4.4.4 }

# delete flowtable <flowtable_spec>
delete flowtable myIpTable myIpFT
delete flowtable ip myIpTable myIpFT
delete flowtable ip6 myIp6Table myIp6FT
delete flowtable inet myInetTable myInetFT
# there is no 'arp/bridge/netdev' in flowtable
delete flowtable table_name handle 15
delete flowtable ip table_name handle 15
delete flowtable ip6 table_name handle 15
delete flowtable inet table_name handle 15
delete flowtable myIpTable myIpFT { hook input priority 0; devices = { br0, eth0, eth1} ; }
delete flowtable ip myIpTable myIpFT { hook input priority 0; devices = { eth0, eth1 } ; }
delete flowtable ip6 myIp6Table myIp6FT { hook input priority 0; devices = { br0, eth0 } ; }
delete flowtable inet myInetTable myInetFT { hook input priority 0; devices = { br0, eth1 } ; }

# delete counter <obj_spec>
delete counter myIpTable myIpCounter
delete counter netdev myNetdevTable myNetdevCounter
delete counter bridge myBridgeTable myBridgeCounter
delete counter arp myArpTable myArpCounter
delete counter ip myIpTable myIpCounter
delete counter ip6 myIp6Table myIp6Counter
delete counter inet myInetTable myInetCounter
delete counter myIpTable https-filter  
delete counter netdev myNetdevTable https-filter  
delete counter bridge myBridgeTable https-filter  
delete counter arp myArpTable https-filter  
delete counter ip myIpTable https-filter  
delete counter ip6 myIp6Table https-filter  
delete counter inet myInetTable https-filter  
# delete counter <objid_spec>
delete counter netdev myNetdevTable handle 1
### delete counter bridge myBridgeTable position 1  # not yet available
###delete counter arp myArpTable index 1  # not yet available

# delete quota <obj_spec>
delete quota table_name quota_name 
delete quota ip table_name quota_name
delete quota ip6 table_name quota_name
delete quota inet table_name quota_name
delete quota arp table_name quota_name
delete quota bridge table_name quota_name
delete quota netdev table_name quota_name
# delete quota <objid_spec>
delete quota table_name handle 15
delete quota ip table_name handle 15
delete quota ip6 table_name handle 15
delete quota inet myInetFilter handle 123
###delete quota inet myInetFilter position 234  # not yet available
###delete quota inet myInetFilter index 345  # not yet available
delete quota arp table_name handle 15
delete quota bridge table_name handle 15
delete quota netdev table_name handle 15

# delete ct <ct_obj_type> <obj_spec> <ct_obj_alloc>
delete ct helper myIpTable cth
delete ct helper netdev myIpTable cth
delete ct helper bridge myIpTable cth
delete ct helper arp myIpTable cth
delete ct helper ip myIpTable cth
delete ct helper ip6 myIpTable cth
delete ct helper inet myIpTable cth

# delete ct <ct_obj_type> <obj_spec> <ct_obj_alloc>
delete ct timeout myIpTable ctt
delete ct timeout netdev myNetdevTable ctt
delete ct timeout bridge myBridgeTable ctt
delete ct timeout arp myArpTable ctt
delete ct timeout ip myIpTable ctt
delete ct timeout ip6 myIp6Table ctt
delete ct timeout inet myInetTable ctt

delete ct expectation table_name quota_name 
delete ct expectation ip table_name quota_name
delete ct expectation ip6 table_name quota_name
delete ct expectation inet table_name quota_name
delete ct expectation arp table_name quota_name
delete ct expectation bridge table_name quota_name
delete ct expectation netdev table_name quota_name

delete limit table_name limit_name 
delete limit ip table_name limit_name
delete limit ip6 table_name limit_name
delete limit inet table_name limit_name
delete limit arp table_name limit_name
delete limit bridge table_name limit_name
delete limit netdev table_name limit_name
delete limit table_name handle 15
delete limit ip table_name handle 15
delete limit ip6 table_name handle 15
delete limit inet table_name handle 15
delete limit arp table_name handle 15
delete limit bridge table_name handle 15
delete limit netdev table_name handle 15
delete secmark table_name secmark_name 
delete secmark ip table_name secmark_name
delete secmark ip6 table_name secmark_name
delete secmark inet table_name secmark_name
delete secmark arp table_name secmark_name
delete secmark bridge table_name secmark_name
delete secmark netdev table_name secmark_name
delete secmark table_name handle 15
delete secmark ip table_name handle 15
delete secmark ip6 table_name handle 15
delete secmark inet table_name handle 15
delete secmark arp table_name handle 15
delete secmark bridge table_name handle 15
delete secmark netdev table_name handle 15
delete synproxy table_name synproxy_name 
delete synproxy ip table_name synproxy_name
delete synproxy ip6 table_name synproxy_name
delete synproxy inet table_name synproxy_name
delete synproxy arp table_name synproxy_name
delete synproxy bridge table_name synproxy_name
delete synproxy netdev table_name synproxy_name
delete synproxy table_name handle 15
delete synproxy ip table_name handle 15
delete synproxy ip6 table_name handle 15
delete synproxy inet table_name handle 15
delete synproxy arp table_name handle 15
delete synproxy bridge table_name handle 15
delete synproxy netdev table_name handle 15

# get_cmd
# Bison: get element set_spec { set_list_member_expr }
# Bison: get element set_spec { set_list_expr , set_list_member_expr }
define variable_name = 123
get element myTable mySetChain { $variable_name }
get element ip filter mySetChain { 1.1.1.1 }
get element ip6 myTable mySetChain { 2.2.2.2, 3.3.3.3 }
get element inet myTable mySetChain { 4.4.4.4 }
get element arp myTable mySetChain{ 4.4.4.4 }
get element bridge myTable mySetChain { 4.4.4.4 }
get element netdev myTable mySetChain { 4.4.4.4 }

# LIST (ordered as in parser_bison.y source code)
# list table <table_spec>
# list_cmd
list table table_name
list table ip table_name
list table ip6 table_name
list table inet table_name
list table arp table_name
list table bridge table_name
list table netdev table_name

list tables 
list tables ip
list tables ip6
list tables inet
list tables bridge
list tables netdev

list chain table_name chain_name 
list chain ip table_name chain_name
list chain ip6 table_name chain_name
list chain inet table_name chain_name
list chain arp table_name chain_name
list chain bridge table_name chain_name
list chain netdev table_name chain_name

list chains 
list chains ip
list chains ip6
list chains inet
list chains arp
list chains bridge
list chains netdev

# list_cmd
# Bison: LIST SETS ruleset_spec
list sets
list sets ip
list sets ip6
list sets inet
list sets arp
list sets bridge
list sets netdev
# Bison: LIST SETS table_spec
list sets table table_name
list sets table ip table_name 
list sets table ip6 table_name 
list sets table inet table_name 
list sets table arp table_name 
list sets table bridge table_name 
list sets table netdev table_name 

list set table_name chain_name 
list set ip table_name chain_name
list set ip6 table_name chain_name
list set inet table_name chain_name
list set arp table_name chain_name
list set bridge table_name chain_name
list set netdev table_name chain_name

list counters table ruleset_spec
list counters table table_name
list counters table ip table_name
list counters table ip6 table_name
list counters table inet table_name
list counters table arp table_name
list counters table bridge table_name

# LIST COUNTER obj_spec close_scope_counter
# Bison: COUNTER obj_spec close_scope_counter
list counter myTable counter_name 
list counter ip myTable counter_name 
list counter ip6 myTable counter_name 
list counter inet myTable counter_name 
list counter arp myTable counter_name 
list counter bridge myTable counter_name 
list counter netdev myTable counter_name 

list quota myTable quota_name
list quota ip myTable quota_name
list quota ip6 myTable quota_name
list quota inet myTable quota_name
list quota arp myTable quota_name
list quota bridge myTable quota_name
list quota netdev myTable quota_name

# list quotas table ruleset_spec
list quotas table table_name
list quotas table ip table_name
list quotas table ip6 table_name
list quotas table inet table_name
list quotas table arp table_name
list quotas table bridge table_name
list quotas table netdev table_name
# list quotas table <table_spec>
list quotas table myIpTable
list quotas table netdev myNetdevTable
list quotas table bridge myBridgeTable
list quotas table arp myArpTable
list quotas table ip myIpTable
list quotas table ip6 myIp6Table
list quotas table inet myInetTable

list limits table ruleset_spec
list limits table table_name
list limits table ip table_name
list limits table ip6 table_name
list limits table inet table_name
list limits table arp table_name
list limits table bridge table_name
list limits table netdev table_name

list limit myTable limit_name
list limit ip myTable limit_name
list limit ip6 myTable limit_name
list limit inet myTable limit_name
list limit arp myTable limit_name
list limit bridge myTable limit_name
list limit netdev myTable limit_name

list secmark myTable secmark_name
list secmark ip myTable secmark_name
list secmark ip6 myTable secmark_name
list secmark inet myTable secmark_name
list secmark arp myTable secmark_name
list secmark bridge myTable secmark_name
list secmark netdev myTable secmark_name

list secmarks table myTable 
list secmarks table ip myTable
list secmarks table ip6 myTable 
list secmarks table inet myTable 
list secmarks table arp myTable 
list secmarks table bridge myTable 
list secmarks table netdev myTable

list synproxy myTable mySynProxy
list synproxy ip myTable mySynProxy
list synproxy ip6 myTable mySynProxy
list synproxy inet myTable mySynProxy
list synproxy arp myTable mySynProxy
list synproxy bridge myTable mySynProxy
list synproxy netdev myTable mySynProxy

list synproxys
list synproxys ip
list synproxys ip6
list synproxys inet
list synproxys arp
list synproxys bridge
list synproxys netdev

list synproxys table myTable
list synproxys table ip myTable
list synproxys table ip6 myTable
list synproxys table inet myTable
list synproxys table arp myTable
list synproxys table bridge myTable
list synproxys table netdev myTable

list flow tables 
list flow tables ip
list flow tables ip6
list flow tables inet

list flow table table_name identifier
list flow table ip table_name identifier
list flow table ip6 table_name identifier
list flow table inet table_name identifier

list meters 
list meters ip
list meters ip6
list meters inet
list meters arp
list meters bridge
list meters netdev

list meter table_name identifier
list meter ip table_name identifier
list meter bridge table_name identifier
list meter netdev table_name identifier

list flowtables 
list flowtables ip
list flowtables ip6
list flowtables inet

list flowtable table_name identifier
list flowtable ip table_name identifier
list flowtable ip6 table_name identifier
list flowtable inet table_name identifier

list maps 
list maps ip
list maps ip6
list maps inet
list maps arp
list maps bridge
list maps netdev
list map table_name chain_name 
list map ip table_name chain_name
list map ip6 table_name chain_name
list map inet table_name chain_name
list map arp table_name chain_name
list map bridge table_name chain_name
list map netdev table_name chain_name
# incomplete list_cmd
#

# reset counters <ruleset_spec>
# Bison: RESET COUNTERS ruleset_spec
reset counters     # this one is covered by RESET COUNTERS table_spec <empty-table>
reset counters ip
reset counters ip6
reset counters inet
reset counters arp
reset counters bridge
reset counters netdev
# Bison: RESET COUNTERS table_spec
###reset counters ip myTable   # not available yet
###reset counters inet myTable   # not available yet
###reset counters arp myTable   # not available yet
###reset counters bridge myTable   # not available yet
###reset counters netdev myTable   # not available yet
# Bison: RESET COUNTERS TABLE table_spec
reset counters table table_name 
reset counters table ip table_name 
reset counters table ip6 table_name 
reset counters table inet table_name 
reset counters table arp table_name 
reset counters table bridge table_name 
reset counters table netdev table_name 

# reset counter <obj_spec>
# Bison: RESET COUNTER obj_spec
reset counter myTable my_custom_counter 

# reset quotas ruleset_spec
# reset quotas [<family>] <table_spec>
reset quotas ip
reset quotas ip6
reset quotas inet
reset quotas arp
reset quotas bridge
reset quotas netdev
###reset quotas ip myIpFilter  # not yet available
###reset quotas ip6 myIpFilter  # not yet available
###reset quotas inet myIpFilter  # not yet available
###reset quotas arp myIpFilter  # not yet available
###reset quotas bridge myIpFilter  # not yet available
###reset quotas netdev myIpFilter  # not yet available
# reset quotas table [<family>] <table_spec>
reset quotas table myIpFilter
reset quotas table netdev myIpFilter
reset quotas table bridge myIpFilter
reset quotas table arp myIpFilter
reset quotas table ip myIpFilter
reset quotas table ip6 myIpFilter
reset quotas table inet myIpFilter

# reset quota <obj_spec>
reset quota myIpTable myFilter ;

# reset_cmd RULES
###reset rules   # covered by 'RESET RULES table_spec'   # not yet available
# Bison: RESET RULES table_spec
###reset rules table_identifier  # not yet available
# Bison: RESET RULES ruleset_spec
###reset rules ip  # not yet available
###reset rules ip6  # not yet available
###reset rules inet  # not yet available
###reset rules arp  # not yet available
###reset rules bridge  # not yet available
###reset rules netdev  # not yet available
# Bison: RESET RULES TABLE table_spec
###reset rules table table_identifier  # not yet available
# Bison: RESET RULES chain_spec
###reset rules table_identifier chain_identifier  # not yet available
# Bison: RESET RULES CHAIN chain_spec
###reset rules chain table_id chain_identifier  # not yet available
###reset rules quota  # not yet available

# Bison: RESET RULE ruleid_spec
# Bison: RESET RULE table_spec identifier handle_spec
# Bison: RESET RULE [family_spec] identifier identifier handle_spec
###reset rule myTable myChain handle 1 # not yet available

### reset element table_name chain_name   # not yet available
### reset element ip table_name chain_name  # not yet available
### reset element ip6 table_name chain_name  # not yet available
### reset element inet table_name chain_name  # not yet available
### reset element arp table_name chain_name  # not yet available
### reset element bridge table_name chain_name  # not yet available
### reset element netdev table_name chain_name  # not yet available

### reset set table_name chain_name  # not yet available
### reset set ip table_name chain_name  # not yet available
### reset set ip6 table_name chain_name  # not yet available
### reset set inet table_name chain_name  # not yet available
### reset set arp table_name chain_name  # not yet available
### reset set bridge table_name chain_name  # not yet available
### reset set netdev table_name chain_name  # not yet available
# reset set ruleid_spec
### reset set table_name handle 15  # not yet available
### reset set ip table_name handle 15  # not yet available
### reset set ip6 table_name handle 15  # not yet available
### reset set inet table_name handle 15  # not yet available
### reset set arp table_name handle 15  # not yet available
### reset set bridge table_name handle 15  # not yet available
### reset set netdev table_name handle 15  # not yet available

### reset map table_name chain_name  # not yet available
### reset map ip table_name chain_name  # not yet available
### reset map ip6 table_name chain_name  # not yet available
### reset map inet table_name chain_name  # not yet available
### reset map arp table_name chain_name  # not yet available
### reset map bridge table_name chain_name  # not yet available
### reset map netdev table_name chain_name  # not yet available
### reset map table_name handle 15  # not yet available
### reset map ip table_name handle 15  # not yet available
### reset map ip6 table_name handle 15  # not yet available
### reset map inet table_name handle 15  # not yet available
### reset map arp table_name handle 15  # not yet available
### reset map bridge table_name handle 15  # not yet available
### reset map netdev table_name handle 15  # not yet available

# FLUSH (flush_cmd)
# flush table <table_spec>
flush table myArpTable
flush table netdev TABLE_NETDEV
flush table bridge myBridgeTable
flush table arp myArpTable
flush table ip myIpTable
flush table ip6 myIp6Table
flush table inet myInetTable

# flush chain <chain_spec>
flush chain myIpTable myIpChain
flush chain netdev myNetdev myNetdevChain
flush chain bridge myBridge myBridgeChain
flush chain arp myArp myArpChain
flush chain ip myIp myIpChain
flush chain ip6 myIp6 myIp6Chain
flush chain inet myInet myInetChain
flush chain myIpTable myIpChain ; flush chain netdev myNetDev X;

# flush set <set_spec>
flush set myIpTable mySet
flush set netdev myNetdevTable mySet
flush set bridge myBridgeTable mySet
flush set arp myArpTable mySet
flush set ip myIpTable mySet
flush set ip6 myIp6Table mySet
flush set inet myInetTable mySet ; 

# flush map <set_spec>
flush map myIpTable myIpMap 
flush map netdev myNetdevTable myNetdevMap 
flush map bridge myBridgeTable myBridgeMap 
flush map arp myArpTable myArpMap 
flush map ip myIpTable myIpMap 
flush map ip6 myIp6Table myIp6Map 
flush map inet myInetTable myInetMap 

# flush flow table <flowtable_spec>
flush flow table myIpTable mySet
flush flow table netdev myNetdevTable mySet
flush flow table bridge myBridgeTable mySet
flush flow table arp myArpTable mySet
flush flow table ip myIpTable mySet
flush flow table ip6 myIp6Table mySet
flush flow table inet myInetTable mySet ; 

# flush meter <set_spec>
flush meter myIpTable mySet
flush meter netdev myNetdevTable mySet
flush meter bridge myBridgeTable mySet
flush meter arp myArpTable mySet
flush meter ip myIpTable mySet
flush meter ip6 myIp6Table mySet
flush meter inet myInetTable mySet ; 

# flush ruleset <ruleset_spec>
flush ruleset
flush ruleset netdev
flush ruleset bridge
flush ruleset arp
flush ruleset ip
flush ruleset ip6
flush ruleset inet

# replace rule <ruleid_spec> <rule>  # TODO
rename chain myIpTable myIpChain newMyIpChain
rename chain netdev myNetdevTable myNetdevChain newMyNetdevChain    ;    
rename chain bridge myBridgeTable myBridgeChain newMyBridgeChain;
rename chain arp myArpTable myArpChain newMyArpChain  ;
rename chain ip myIpTable myIpChain newMyIpChain    ;    # comment
rename chain ip6 myIp6Table myIp6Chain newMyIp6Chain  # comment
rename chain inet myInetTable myInetChain newMyInetChain

# IMPORT
import ruleset xml
import ruleset json
import ruleset vm json

# export_cmd
export ruleset xml
export ruleset json



# add quota <obj_spec> <quota_obj>
# add quota <obj_spec> <quota_config>
# add quota <obj_spec> <quota_mode> NUM <quota_unit> <quota_used>
# create quota <obj_spec> <quota_obj>
# create quota <obj_spec> <quota_config>
# create quota <obj_spec> <quota_mode> NUM <quota_unit> <quota_used>
#
# also as part of 'table':
# <table_block> quota <quota_name> { <quota_block> }
# table myTable {
#     chain myChain {
#         quota <quota_name> { <quota_block; ... }
#         <quota_stmt>
#         quota <quota_mode> NUM <quota_unit> <quota_used>
#         quota name <stmt_expr>
#     }
# }
# <rule>
# <rule_alloc>
# <rule_alloc> <comment>
# <stmt_list> <comment>
# <stmt> <comment>
# <quota_stmt> <quota_stmt>
# quota <quota_mode> NUM <quota_unit> <quota_used>
# quota <quota_config>  # Let's use this condense version
#
# TODO Need to study syntax for secmark/synproxy

#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# list quota <obj_spec>
list quota
list quota myInetTable myInetChain
list quota netdev myNetdevTable myNetdevChain
list quota bridge myBridgeTable myBridgeChain
list quota arp myArpTable myArpChain
list quota ip myIpTable myIpChain
list quota ip6 myIp6Table myIp6Chain
list quota inet myInetTable myInetChain

# list limits <ruleset_spec>
list limits
list limits netdev
list limits bridge
list limits arp
list limits ip
list limits ip6
list limits inet

# list limit <obj_spec>
list limit myIpTable myIpChain
list limit netdev myNetdevTable myNetdevChain
list limit ip myBridgeTable myBridgeChain
list limit ip myArpTable myArpChain
list limit ip myIpTable myIpChain
list limit ip myIp6Table myIp6Chain
list limit ip myInetTable myInetChain

# list ruleset <ruleset_spec>
list ruleset   
list ruleset  ;  
list ruleset netdev
list ruleset bridge
list ruleset arp
list ruleset ip
list ruleset ip6
list ruleset inet
list ruleset inet

list ruleset netdev oopsie;  # invalid syntax

list flowtable netdev myIpTable myIpFT  # intentional syntax error
# list flow tables <ruleset_spec>
list flow tables   
list flow tables  ;  
list flow tables netdev
list flow tables bridge
list flow tables arp
list flow tables ip
list flow tables ip6
list flow tables inet

# list flow table <set_spec>
list flow table   
list flow table  ;  
list flow table myIpTable myIpFlow;  
list flow table netdev myNetdevTable myNetdevFlow
list flow table bridge myBridgeTable myBridgeFlow
list flow table arp myArpTable myArpFlow
list flow table ip myIpTable myIpFlow;  
list flow table ip6 myIp6Table myIp6Flow
list flow table inet myInetTable myInetFlow

# list meters <ruleset_spec>
list meters   
list meters  ;  
list meters netdev
list meters bridge
list meters arp
list meters ip
list meters ip6
list meters inet

# list meter <set_spec>
list meter myIpTable myIpMeter
list meter myIpTable myIpMeter ;  
list meter netdev myNetdevTable myNetdevMeter
list meter bridge myBridgeTable myBridgeMeter
list meter arp myArpTable myArpMeter
list meter ip myIpTable myIpMeter
list meter ip6 myIp6Table myIp6Meter
list meter inet myInetTable myInetMeter
list meter ip filter flood

# list flowtables <ruleset_spec>
#   (legacy keywords, got joined together later on)
list flowtables   
list flowtables  ;  
list flowtables netdev
list flowtables bridge
list flowtables arp
list flowtables ip
list flowtables ip6
list flowtables inet

# list maps <ruleset_spec>
list maps
list maps netdev 
list maps bridge 
list maps arp 
list maps ip 
list maps ip6 
list maps inet 

# list map <set_spec>
list map myIpTable myIpMap 
list map netdev myNetdevTable myNetdevMap 
list map bridge myBridgeTable myBridgeMap 
list map arp myArpTable myArpMap 
list map ip myIpTable myIpMap 
list map ip6 myIp6Table myIp6Map 
list map inet myInetTable myInetMap 

# list ct helpers table <table_spec>
list ct helpers table    # missing table name
list ct helpers table myIpTable
list ct helpers table netdev myNetdevTable
list ct helpers table bridge myBridgeTable
list ct helpers table arp myArpTable
list ct helpers table ip myIpTable
list ct helpers table ip6 myIp6Table
list ct helpers table inet myInetTable

# list ct helpers table <table_spec>
list ct helpers table myIpTable
list ct helpers table netdev myNetdevTable
list ct helpers table bridge myBridgeTable
list ct helpers table arp myArpTable
list ct helpers table ip myIpTable
list ct helpers table ip6 myIp6Table
list ct helpers table inet myInetTable

ct helper myHelper { type "myFtp" protocol tcp ; l3proto ip }

export json
export xml
export ruleset json
export ruleset xml

describe tcp flag; # oopsie

# reset counters <ruleset_spec>
reset counters
reset counters netdev
reset counters bridge
reset counters arp
reset counters ip
reset counters ip6
reset counters inet

# reset counters table <table_spec>
reset counters table myIpTable
reset counters table netdev myNetdevTable
reset counters table bridge myBridgeTable
reset counters table arp myArpTable
reset counters table ip myIpTable
reset counters table ip6 myIp6Table
reset counters table inet myInetTable

# reset counter <obj_spec>
reset counter netdev
reset counter bridge
reset counter arp
reset counter ip
reset counter ip6
reset counter inet
reset counter netdev myNetdevTable
reset counter bridge myBridgeTable
reset counter arp myArpTable
reset counter ip myIpTable
reset counter ip6 myIp6Table
reset counter inet myInetTable

# reset counter <objid_spec>
reset counter myIpTable handle 5
reset counter netdev myNetdevTable handle 5
reset counter bridge myBridgeTable handle 5
reset counter arp myArpTable handle 5
reset counter ip myIpTable handle 5
reset counter ip6 myIp6Table handle 5
reset counter inet myInetTable handle 5


# delete chain <chain_spec>
delete chain myIpTable myIpChain
delete chain netdev myNetdev myNetdevChain
delete chain bridge myBridge myBridgeChain
delete chain arp myArp myArpChain
delete chain ip myIp myIpChain
delete chain ip6 myIp6 myIp6Chain
delete chain inet myInet myInetChain
# delete chain <chainid_spec>
delete chain myInet handle 123123
delete chain inet myInet handle 42 # comment

# MONITOR
monitor 

# monitor [new | destroy] [tables | chains | sets | rules | elements] [xml | json]
# monitor <monitor_event> 
monitor new  # monitor 'ANY'
# monitor <monitor_event> <monitor_object> 
monitor new tables 
monitor new chains
monitor new sets
monitor new rules
monitor new elements 
monitor new ruleset
monitor new trace 
# monitor /* empty */ <monitor_object> 
monitor tables;
monitor chains
monitor sets
monitor rules
monitor elements
monitor ruleset
monitor trace
# monitor /* empty */ <monitor_object> <monitor_format>
monitor tables json;
monitor chains xml
monitor sets json
monitor rules vm json
monitor elements json
monitor ruleset json
monitor trace json
monitor trace json
# monitor <monitor_event> <monitor_object> <monitor_format>
monitor new tables json
monitor new chains json
monitor new sets vm json
monitor new rules json
monitor new elements json
monitor new ruleset json
monitor new trace  json
#
monitor destroy 
monitor destroy tables 
monitor destroy chains
monitor destroy sets
monitor destroy rules
monitor destroy elements
monitor destroy trace 

# COMPLEX REAL-WORLD EXAMPLES
table arp A0b_._/RP_TABLE {
    chain ARP_INPUT_FILTER {
       type filter hook input priority 0;
       policy drop;
       counter log drop
    }
    chain ARP_INPUT_FILTER {
       type filter hook prerouting priority 0;
       policy drop;
       counter log return
    }
    chain workstation_arp_filter_output {
        type filter hook output priority 0;
        policy drop;
        counter log drop
    }
}

table netdev NETDEV_TABLE {
    # mind the NIC, it must exists
    chain ingress_filter_netdev_lo { 
        type filter hook ingress device lo priority -100; policy accept
        udp dport 53 ether type 0x8006 ether saddr set aa:bb:cc:dd:ff:ee ether daddr set numgen inc mod 2 map {  0 : ca:fe:ba:be:00:00, 1: de:ad:be:ef:00:00 } fwd to eth0;
    };
    chain red_ingress_netdev_eth0 { 
        # You'll get a cryptic error if 'device eth0' is missing after 'chain'
        type filter hook ingress device eth0 priority -100; 
        policy accept;

        # tcp dport 80 ether saddr set aa:bb:cc:dd:ff:ee ether daddr set jhash ip saddr . tcp sport mod 2 map { 0 : ca:fe:ba:be:00:00, 1: de:ad:be:ef:00:00 } fwd to eth0;
        udp dport 53 ether saddr set aa:bb:cc:dd:ff:ee ether daddr set numgen inc mod 2 map {  0 : ca:fe:ba:be:00:00, 1: de:ad:be:ef:00:00 } fwd to eth0;
    }
}

table bridge workstation_bridge {
    chain workstn_bridge_filter_input {
        type filter hook input priority -200;
        policy accept;
        ct state established,related accept # handle 4
        ct helper ftp-standard {
            type "ftp" protocol tcp
        }
    }
    chain workstn_bridge_filter_output {
        type filter hook output priority -200;
        policy accept;
    }

    chain workstn_bridge_filter_forward {
        type filter hook forward priority -200;
        # default drop on all bridge forwarding
        policy drop;

        oif eth0 ip protocol icmp icmp type echo-request accept
        iif eth0 ip protocol icmp icmp type echo-reply accept
        counter log drop
    }
}

table inet INET_TABLE {
define interface_name2 = "br0"
    chain workstation_inet_filter_input {
        # Things that make this chain unique (input, filter)
        type filter hook input priority 0;
        policy drop;
        iif lo accept
        # Things that make this chain unique ('eth0', input, filter)
        # meta iifname != $interface_name2 drop;  # workstation wants all intfs
        # Let things back in if they've been established before new firewall
        ct state established,related accept;
        #  DNS 
        tcp dport 53 counter accept 
        udp dport 53 counter accept 
        #  Multicast DNS 
        tcp dport 5353 counter accept
        # RFC 6092 - Simple Security in IPv6 Gateway CPE
        # recommends that the DEFAULT
        #   operating mode for residential IPv6 simple security be to treat
        #   Generic Packet Tunneling [RFC2473] and similar protocols as opaque
        #   transport layers, i.e., inbound tunnel initiations are denied and
        #   outbound tunnel initiations are accepted.

        # To facilitate the use of IPsec in support of IPv6
        # mobility, the Internet Key Exchange (IKE) protocol [RFC5996] and the
        # Host Identity Protocol (HIP) [RFC5201] should also be permitted in
        # the DEFAULT operating mode.

        #  Workstation
        icmp type {
            destination-unreachable, 
            time-exceeded, 
            parameter-problem
        } counter accept

        # Router/Gateway
        icmp type {
            destination-unreachable, 
            redirect, 
            time-exceeded, 
            parameter-problem, 
            router-advertisement, 
            router-solicitation
            } counter accept

        # All ICMP
        icmp type {
            echo-reply, 
            destination-unreachable, 
            source-quench, redirect, 
            echo-request, 
            time-exceeded, 
            parameter-problem, 
            timestamp-request, 
            timestamp-reply, 
            info-request, 
            info-reply, 
            address-mask-request, 
            address-mask-reply, 
            router-advertisement, 
            router-solicitation
            } counter accept

        tcp dport 25 counter accept    # smtp
        tcp dport 465 counter accept   # submission
        # SSH server
        tcp dport ssh counter accept 
        
        tcp dport 514 counter accept    # syslog
        tcp dport 6514 counter accept   # secured syslog

        tcp dport 80 counter accept 
        tcp dport 443 counter accept 

        # IP-specific
        # meta ip goto workstation_inet_filter_input_ip
        # meta ip6 goto workstation_inet_filter_input_ip6
        # meta vlan goto workstation_inet_filter_input_vlan
        # meta arp goto workstation_inet_filter_input_arp

        # Just in case that someone screws up our 'policy drop'

        # multi-family reject, using the icmpx keyword
        counter log reject with icmpx type admin-prohibited
    };
    # ARP filter input
    chain workstation_arp_filter_input {
        counter log reject
    }
    # ARP filter output
    chain workstation_arp_filter_output {
        #  Multicast DNS 
        tcp dport 5353 counter accept
        #  DNS 
        tcp dport 53 counter accept 
        udp dport 53 counter accept 

        #  Workstation
        icmp type {
            destination-unreachable, 
            time-exceeded, 
            parameter-problem
            } counter accept

        # Router/Gateway
        icmp type {
            destination-unreachable, 
            redirect, 
            time-exceeded, 
            parameter-problem, 
            router-advertisement, 
            router-solicitation
            } counter accept

        # All ICMP
        icmp type {
            echo-reply, 
            destination-unreachable, 
            source-quench, redirect, 
            echo-request, 
            time-exceeded, 
            parameter-problem, 
            timestamp-request, 
            timestamp-reply, 
            info-request, 
            info-reply, 
            address-mask-request, 
            address-mask-reply, 
            router-advertisement, 
            router-solicitation
            } counter accept

        tcp dport 25 counter accept    # smtp
        tcp dport 465 counter accept   # submission
        # SSH server
        tcp dport ssh counter accept 

        tcp dport 514 counter accept    # syslog
        tcp dport 6514 counter accept   # secured syslog

        tcp dport 80 counter accept 
        tcp dport 443 counter accept 

        counter log reject
    }
    #IPv6 filtering
    chain workstation_ip6_filter_input {
        counter log reject
    }
    #IPv6 filtering
    chain workstation_inet_filter_input_ip6 {
        counter log reject
    }
    #IPv6 filtering
    chain workstation_inet_filter_input_ip6 {
        counter log reject
    }
}

table ip workstn_ip_nat {
    chain workstn_ip_nat_postrouting {
        type nat hook postrouting priority 0;
        #Likewise, in iptables NAT (source NAT):
        # % iptables -t nat -A POSTROUTING -s 192.168.1.1 -j SNAT --to-source 1.1.1.1
        # % iptables -t nat -A POSTROUTING -s 192.168.2.2 -j SNAT --to-source 2.2.2.2
        # % iptables -t nat -A POSTROUTING -s 192.168.3.3 -j SNAT --to-source 3.3.3.3

        # Translated to a nftables one-liner:

        # snat ip saddr map { 
        #     192.168.1.1 : 1.1.1.1, 
        #     192.168.2.2 : 2.2.2.2, 
        #     192.168.3.3 : 3.3.3.3 
       #  }
    }
}


# ct mark set meta mark

table inet raw {
    chain prerouting {
        type filter hook prerouting priority -300;
        ct zone set iif map { "eth1" : 1, "veth1" : 2 }
    }
    chain output {
        type filter hook output priority -300;
        ct zone set oif map { "eth1" : 1, "veth1" : 2 }
    }
}

table inet filter {
    chain input {
        type filter hook input priority 0; policy accept;
        ct state established,related accept # handle 4
        ip saddr 10.1.1.1 tcp dport ssh accept # handle 5
    }
}
table ip my_filter_table {
    set my_connlimit {
        type ipv4_addr
        size 65535
        flags dynamic
    }

    chain my_output_chain {
        type filter hook output priority filter; policy accept;
        ct state new add @my_connlimit { ip daddr ct count over 20 } counter packets 0 bytes 0 drop
   }
}

table ip filter {
    set myset {
        type inet_service
        flags timeout
        elements = { http expires 9s}
    }

    chain input {
        type filter hook input priority 0; policy accept;
        update @myset { tcp dport timeout 1m }
    }
}

table ip filter {
    set myset {
        type ipv4_addr
        elements = { 1.1.1.1 }
    }

    chain input {
        type filter hook input priority 0; policy accept;
        add @myset { ip saddr }
    }
}

table inet myfilter {
    set myset {
        type ipv4_addr
        flags timeout
        elements = { 10.0.0.1 timeout 10s expires 8s}
    }
}

# fw.basic
table ip filter {
    chain input {
        type filter hook input priority 0;
        # accept traffic originated from us
        ct state established,related accept
        # accept any localhost traffic
        iif lo accept
        # count and drop any other traffic
        counter drop
    }
}

# fw6.basic
table ip6 filter {
    chain input {
        type filter hook input priority 0;
        # accept any localhost traffic
        iif lo accept
        # accept traffic originated from us
        ct state established,related accept
        # accept neighbour discovery otherwise connectivity breaks
        icmpv6 type { nd-neighbor-solicit, echo-request, nd-router-advert, nd-neighbor-advert } accept
        # count and drop any other traffic
        counter drop
    }
}

# fw.inet.basic
table inet filter {
    chain input {
        type filter hook input priority 0;
        # accept any localhost traffic
        iif lo accept
        # accept traffic originated from us
        ct state established,related accept
        # accept neighbour discovery otherwise connectivity breaks
        ip6 nexthdr icmpv6 icmpv6 type { nd-neighbor-solicit, echo-request, nd-router-advert, nd-neighbor-advert } accept
        # count and drop any other traffic
        counter drop
    }
}

table inet filter {
    chain global {
        ct state established,related accept
        ct state invalid drop
        ip protocol icmp accept
        ip6 nexthdr icmpv6 accept
        udp dport 53 accept
    }
    set myset_ipv4 {
        type ipv4_addr;
        elements = { $server1_ipv4 , $workstation1_ipv4 }
    }
    set myset_ipv6 {
        type ipv6_addr;
        elements = { $server1_ipv6 , $workstation1_ipv6 }
    }
    chain dmz_in {
        # your rules for traffic to your dmz servers
        ip saddr @myset_ipv4
        ip6 saddr @myset_ipv6
    }
    chain dmz_out {
        # your rules for traffic from the dmz to internet
    }
    chain lan_in {
        # your rules for traffic to your LAN nodes
    }
    chain lan_out {
        # your rules for traffic from the LAN to the internet
    }
    chain forward {
        type filter hook forward priority 0; policy drop;
        jump global
        oifname vmap { $nic_dmz : jump dmz_in , $nic_lan : jump lan_in }
        oifname $nic_inet iifname vmap { $nic_dmz : jump dmz_out , $nic_lan : jump lan_out }
    }
    chain input {
        type filter hook input priority 0 ; policy drop;
        jump global
        # your rules for traffic to the firewall here
    }
    chain output {
        type filter hook output priority 0 ; policy drop;
        jump global
        # your rules for traffic originated from the firewall itself here
    }
}

# Port Knocking Example #1
table inet portknock {
    set clients_ipv4 {
        type ipv4_addr
        flags timeout
    }
    set clients_ipv6 {
        type ipv6_addr
        flags timeout
    }
    set candidates_ipv4 {
        type ipv4_addr . inet_service
        flags timeout
    }
    set candidates_ipv6 {
        type ipv6_addr . inet_service
        flags timeout
    }
    chain input {
        type filter hook input priority -10; policy accept;

        iifname "lo" return

        tcp dport 123 add @candidates_ipv4 {ip  saddr . 234 timeout 1s}
        tcp dport 123 add @candidates_ipv6 {ip6 saddr . 234 timeout 1s}
        tcp dport 234 ip  saddr . tcp dport @candidates_ipv4 add @candidates_ipv4 {ip  saddr . 345 timeout 1s}
        tcp dport 234 ip6 saddr . tcp dport @candidates_ipv6 add @candidates_ipv6 {ip6 saddr . 345 timeout 1s}
        tcp dport 345 ip  saddr . tcp dport @candidates_ipv4 add @candidates_ipv4 {ip  saddr . 456 timeout 1s}
        tcp dport 345 ip6 saddr . tcp dport @candidates_ipv6 add @candidates_ipv6 {ip6 saddr . 456 timeout 1s}
        tcp dport 456 ip  saddr . tcp dport @candidates_ipv4 add @clients_ipv4 {ip  saddr timeout 10s} log prefix "Successful portknock: "
        tcp dport 456 ip6 saddr . tcp dport @candidates_ipv6 add @clients_ipv6 {ip6 saddr timeout 10s} log prefix "Successful portknock: "
        tcp dport $guarded_ports ip  saddr @clients_ipv4 counter accept
        tcp dport $guarded_ports ip6 saddr @clients_ipv6 counter accept
        tcp dport $guarded_ports ct state established,related counter accept
        tcp dport $guarded_ports counter reject with tcp reset
    }
}

# Port Knocking Example #2
table ip Inet4 {
    set Knocked_1 {
        type ipv4_addr
        flags timeout
        timeout 10s
        gc-interval 4s
    }
    set Knocked_2 {
        type ipv4_addr
        flags timeout
        timeout 10s
        gc-interval 4s
    }
    set Knocked_3 {
        type ipv4_addr
        flags timeout
        timeout 10s
        gc-interval 4s
    }
    set Knocked_4 {
        type ipv4_addr
        flags timeout
        timeout 2m
        gc-interval 4s
    }

    chain Knock_1 {
        set add ip saddr @Knocked_1
    }
    chain Unknock_1 {
        set update ip saddr timeout 0s @Knocked_1
    }
    chain Knock_2 {
        set update ip saddr timeout 0s @Knocked_1
        set add ip saddr @Knocked_2
    }
    chain Unknock_2 {
        set update ip saddr timeout 0s @Knocked_2
    }
    chain Knock_3 {
        set update ip saddr timeout 0s @Knocked_2
        set add ip saddr @Knocked_3
    }
    chain Unknock_3 {
        set update ip saddr timeout 0s @Knocked_3
    }
    chain Knock_4 {
        set update ip saddr timeout 0s @Knocked_3
        set add ip saddr @Knocked_4 log prefix "Port-Knock accepted: "
    }
    chain RefreshKnock {
        set update ip saddr timeout 2m @Knocked_4
    }
    chain PortKnock {
        ct state new ip saddr @Knocked_4 goto RefreshKnock
        tcp dport 456 ct state new ip saddr @Knocked_3 goto Knock_4
        tcp dport 345 ct state new ip saddr @Knocked_3 return
        ip saddr @Knocked_3 ct state new goto Unknock_3
        tcp dport 345 ct state new ip saddr @Knocked_2 goto Knock_3
        tcp dport 234 ct state new ip saddr @Knocked_2 return
        ip saddr @Knocked_2 ct state new goto Unknock_2
        tcp dport 234 ct state new ip saddr @Knocked_1 goto Knock_2
        tcp dport 123 ct state new ip saddr @Knocked_1 return
        ip saddr @Knocked_1 ct state new goto Unknock_1
        tcp dport 123 ct state new goto Knock_1
    }
    chain FilterIn {
        type filter hook input priority 0
        policy drop

        # allow established/related connections
        ct state established,related accept

        # early drop of invalid connections
        ct state invalid drop

        # allow from loopback
        meta iif lo accept

        # allow icmp
        ip protocol icmp accept

        # port-knocking
        jump PortKnock

        # misc. filtering
        # ...
    }

    chain FilterOut {
        type filter hook output priority 0
        policy accept
    }
}

# Classification to tc structure
table ip filter {
   map subnet_map {
       type ipv4_addr : verdict
       flags interval
       elements = { 10.20.255.48/29 : goto group_114, 10.20.255.88/29 : goto group_114,
                    10.20.255.128/29 : goto group_114 }
   }
   set priority_set {
       type ipv4_addr
       flags interval
       elements = { 8.8.8.8, 8.8.4.4 }
   }   
   map group_114 {
       type ipv4_addr : classid
       flags interval
       elements = { 10.20.255.50 : 1:ffd8, 10.20.255.90 : 1:ffd5,
                     10.20.255.130 : 1:ffd2 }
   }
   map group_114_prio {
       type ipv4_addr : classid
       flags interval
       elements = { 10.20.255.50 : 1:ffd9, 10.20.255.90 : 1:ffd6,
                     10.20.255.130 : 1:ffd3 }
   }   
   chain forward {
       type filter hook forward priority filter; policy accept;
       meta priority none ip daddr vmap @subnet_map counter packets 0 bytes 0
       meta priority none ip saddr vmap @subnet_map counter packets 0 bytes 0
       ip daddr 192.168.0.0/16 meta priority none meta priority set 1:ffff counter packets 0 bytes 0 log prefix "total - "
       ip saddr 192.168.0.0/16 meta priority none meta priority set 1:ffff counter packets 0 bytes 0 log prefix "total - "
       ip daddr 10.0.0.0/8 meta priority none meta priority set 1:ffff counter packets 38931 bytes 2926076 log prefix "total - "
       ip saddr 10.0.0.0/8 meta priority none meta priority set 1:ffff counter packets 14 bytes 1064 log prefix "total - "
       meta priority none meta priority set 1:2 counter packets 0 bytes 0 log prefix "non_shaped - "
   }
   chain input {
       type filter hook input priority filter; policy accept;
       meta priority none meta priority set 1:2 counter packets 419381 bytes 45041195
   }
   chain output {
       type filter hook output priority filter; policy accept;
       meta priority none meta priority set 1:2 counter packets 507779 bytes 51809859
   }
   chain group_114 {
       meta priority none ip saddr @priority_set meta priority set ip daddr map @group_114_prio counter packets 0 bytes 0
       meta priority none ip daddr @priority_set meta priority set ip saddr map @group_114_prio counter packets 0 bytes 0
       meta priority none meta priority set ip daddr map @group_114 counter packets 0 bytes 0
       meta priority none meta priority set ip saddr map @group_114 counter packets 0 bytes 0
       meta priority none meta priority set 1:ffff counter packets 0 bytes 0 log prefix "group_114 - "
   }
}

# Will count all udp port 5060 packets towards the 
# quota and drop all packets once the quota hits 
# its "over 100 mbytes" threshold.
table inet foo {
    quota example { over 100 mbytes used 0 bytes }

    chain dropafterquota {
        type filter hook postrouting priority 0; policy accept;
        udp port 5060 quota name "example" drop
    }
}
table ip x {
    chain c {
        ct timeout set saddr map {
            192.168.0.14 :"policy1"
        }
    }
    ct timeout "policy1" {
        protocol tcp
        timeouts = {
            established: 120s
            fin_wait: 30;
        }
    }
}

table firewall {
  chain incoming {
    type filter hook input priority 0; policy drop;

    # established/related connections
    ct state established,related accept

    # loopback interface
    iifname lo accept

    # icmp
    icmp type echo-request accept

    # open tcp ports: sshd (22), httpd (80)
    tcp dport { ssh, http } accept
  }
}

table ip6 firewall {
  chain firewall incoming {
    type filter hook input priority 0; policy drop;

    # established/related connections
    ct state established,related accept

    # invalid connections
    ct state invalid drop

    # loopback interface
    iifname lo accept

    # icmp
    # routers may also want: mld-listener-query, nd-router-solicit
    icmpv6 type { echo-request, nd-neighbor-solicit } accept

    # open tcp ports: sshd (22), httpd (80)
    tcp dport { ssh, http } accept
  }
}

#  No error syntaxes here
#  See error-syntaxes.nft for actual errors in Vim/NeoVim syntax error

# Bison: SET set_spec 
set myTable mySetName 
set ip myTable mySetName 
set ip6 myTable mySetName 
set inet myTable mySetName 
set arp myTable mySetName 
set bridge myTable mySetName 
set netdev myTable mySetName 
list sets table table_name chain_name   # extraneous chain_name
list sets table ip table_name chain_name  # extraneous chain_name
list sets table ip6 table_name chain_name  # extraneous chain_name
list sets table inet table_name chain_name  # extraneous chain_name
list sets table arp table_name chain_name  # extraneous chain_name
list sets table bridge table_name chain_name
list sets table netdev table_name chain_name
reset quota ip
reset quota ip6
reset quota inet
reset quota arp
reset quota bridge
reset quota netdev
reset quota ip myIpFilter https-quota
reset quota ip6 myIp6Filter https-quota
reset quota inet myInetFilter https-quota
reset quota arp myArpFilter https-quota
reset quota bridge myBridgeFilter https-quota
reset quota netdev myBridgeFilter https-quota

# stmt
# stmt->verdict_stmt
add rule myTable myChain accept
add rule myTable myChain drop
add rule myTable myChain continue
add rule myTable myChain return
add rule myTable myChain jump last
add rule myTable myChain jump $chainvar
add rule myTable myChain jump AltChain
add rule myTable myChain goto AltChain

add rule myTable myChain ct mark 

add rule myTable myChain vmap MyMeter

# stmt->meter_stmt
myTable myChain meter MyMeter { ip saddr } 
rule myTable myChain meter MyMeter { ip saddr } 
rule myTable myChain meter MyMeter { ip saddr } accept
rule myTable myChain meter MyMeter { tcp dport . ip saddr limit rate over 200/second } counter drop
add rule myTable myChain meter MyMeter size 1250 { ip saddr } 
add rule myTable myChain meter MyMeter size 1250 { ip saddr } accept
add rule myTable myChain meter MyMeter size 1250 { tcp dport . ip saddr limit rate over 200/second } counter drop

myTable myChain meter   # error: Unexpected EOS
myTable myChain meter ;  # error: unexpected semicolon
add rule myTable myChain meter  # error: premature EOS
add rule myTable myChain meter MyMeter;  # error: premature ';'
add rule myTable myChain meter MyMeter  # error: premature EOS
add rule myTable myChain meter MyMeter size  # error: premature EOS
add rule myTable myChain meter MyMeter size 1250  # error: premature EOS
add rule myTable myChain meter MyMeter size 1250 ;  # error: premature ';'
add rule myTable myChain meter MyMeter { ;  };  # error: premature semicolon

# stmt->payload_stmt
add rule myTable myChain icmp 15
add rule myTable myChain ether 15
add rule myTable myChain vlan 15
add rule myTable myChain arp 15
add rule myTable myChain ip 15
add rule myTable myChain igmp 15
add rule myTable myChain ip6 15
add rule myTable myChain icmp6 15
add rule myTable myChain auth 15
add rule myTable myChain esp 15
add rule myTable myChain comp 15
add rule myTable myChain udp 15
add rule myTable myChain udplite 15
add rule myTable myChain tcp 15
add rule myTable myChain dccp 15
add rule myTable myChain sctp 15
add rule myTable myChain th 15
add rule myTable myChain vxlan 15
add rule myTable myChain geneve 15
add rule myTable myChain gre 15
add rule myTable myChain gretap 15

# stmt->stateful_stmt
#
#    @nft_c_reject_stmt,
add rule T C reject with icmp
add rule T C reject with icmp6 type 3
add rule T C reject with icmp6 type echo-request
add rule T C reject with icmpx
add rule T C reject with tcp reset

#    nft_log_stmt,
add rule T C log prefix "LOG:
add rule T C log group 11 
add rule T C log snaplen 15
add rule T C log queue-threshold 15
add rule T C log level 7
add rule T C log flags all
add rule T C log flags tcp seq
add rule T C log flags tcp options
add rule T C log flags tcp seq,options
add rule T C log flags tcp options,seq
add rule T C log flags ip options
add rule T C log flags skuid
add rule T C log flags ether
add rule T C log flags all
#    nft_nat_stmt,
#    @nft_c_meta_stmt,
#    nft_masq_stmt,
#    @nft_c_redir_stmt,
#    nft_tproxy_stmt,
#    @nft_c_queue_stmt,
#    nft_dup_stmt,
#    nft_fwd_stmt,
#    @nft_c_set_stmt,
#    @nft_c_map_stmt,
#    nft_optstrip_stmt,
#    nft_xt_stmt,
#    nft_objref_stmt,
add rule T C ct expectation   # unexpected EOS
add rule T C ct timeout   # unexpected EOS
add rule T C ct   # unexpected EOS
#    nft_synproxy_stmt,
#    @nft_c_chain_stmt
#
